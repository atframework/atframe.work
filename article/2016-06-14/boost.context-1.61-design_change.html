<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>boost.context-1.61版本的设计模型变化 • atframework</title>
    <meta name="description" content="



">
    <meta name="keywords" content="boost, coroutine, c++, cpp, cxx">
    
    
	<!-- Twitter Cards -->
	<meta name="twitter:title" content="boost.context-1.61版本的设计模型变化">
	<meta name="twitter:description" content="



">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="/images/logo-m.png">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="cn">
	<meta property="og:type" content="article">
	<meta property="og:title" content="boost.context-1.61版本的设计模型变化">
	<meta property="og:description" content="



">
	<meta property="og:url" content="/article/2016-06-14/boost.context-1.61-design_change.html">
	<meta property="og:site_name" content="atframework">

    <link rel="canonical" href="/article/2016-06-14/boost.context-1.61-design_change.html">

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="atframework Atom Feed">
    <link href="/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <link rel="stylesheet" href="/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="/js/vendor/html5shiv.min.js"></script>
      <script src="/js/vendor/respond.min.js"></script>
    <![endif]-->

  </head>

  <body id="js-body">
    <!--[if lt IE 9]><div class="upgrade notice-warning"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

    <header id="masthead">
  <div class="inner-wrap">
    <a href="/" class="site-title">atframework</a>
    <nav role="navigation" class="menu top-menu">
        




<ul class="menu-item">
	<li class="home"><a href="/">atframework</a></li>
	
    
    <li><a href="/cn/quick_start/" >快速上手</a></li>
  
    
    <li><a href="/cn/document/" >文档</a></li>
  
    
    <li><a href="/cn/projects/" >项目列表</a></li>
  
    
    <li><a href="/cn/articles/" >技术分享</a></li>
  
    
    <li><a href="/cn/about/" >关于</a></li>
  

  
</ul>
    </nav>
  </div><!-- /.inner-wrap -->
</header><!-- /.masthead -->
    




<nav role="navigation" id="js-menu" class="sliding-menu-content">
  <h5>atframework <span>目录</span></h5>
  <ul class="menu-item">
    <li>
      <a href="/cn/quick_start/">
        
        <div class="title">快速上手</div>
        
      </a>
    </li><li>
      <a href="/cn/document/">
        
        <div class="title">文档</div>
        
      </a>
    </li><li>
      <a href="/cn/projects/">
        
        <div class="title">项目列表</div>
        
      </a>
    </li><li>
      <a href="/cn/articles/">
        
        <div class="title">技术分享</div>
        
      </a>
    </li><li>
      <a href="/cn/about/">
        
        <div class="title">关于</div>
        
      </a>
    </li>
    
  </ul>
</nav>
<button type="button" id="js-menu-trigger" class="sliding-menu-button lines-button x2" role="button" aria-label="Toggle Navigation">
  <span class="nav-lines"></span>
</button>

<div id="js-menu-screen" class="menu-screen"></div>


    <div id="page-wrapper">
      <div id="main" role="main">
	<article class="wrap" itemscope itemtype="http://schema.org/Article">
		
		
  <nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="" itemprop="url">
        <span itemprop="title">Home</span>
      </a> › 
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="/article/" itemprop="url">
        <span itemprop="title">Article</span>
      </a>
    </span>
  </nav><!-- /.breadcrumbs -->

		<div class="page-title">
			<h1>boost.context-1.61版本的设计模型变化</h1>
		</div>
		<div class="inner-wrap">
			<div id="content" class="page-content" itemprop="articleBody">
				<nav class="toc">
<ul id="markdown-toc">
  <li><a href="#前言" id="markdown-toc-前言">前言</a></li>
  <li><a href="#设计模型变化" id="markdown-toc-设计模型变化">设计模型变化</a>    <ul>
      <li><a href="#api变化" id="markdown-toc-api变化">API变化</a></li>
      <li><a href="#流程变化" id="markdown-toc-流程变化">流程变化</a></li>
      <li><a href="#向前兼容" id="markdown-toc-向前兼容">向前兼容</a></li>
      <li><a href="#execution_context_v2" id="markdown-toc-execution_context_v2">execution_context_v2</a></li>
    </ul>
  </li>
  <li><a href="#存在的问题" id="markdown-toc-存在的问题">存在的问题</a></li>
  <li><a href="#其他不是很重要的变化" id="markdown-toc-其他不是很重要的变化">其他不是很重要的变化</a></li>
  <li><a href="#libcopp的修订" id="markdown-toc-libcopp的修订">libcopp的修订</a></li>
</ul>

</nav>

<h2 id="前言">前言</h2>
<p>之前写了个C++的协程框架<a href="https://github.com/owt5008137/libcopp">libcopp</a>，底层使用的是boost.context实现，然后剥离了对boost的依赖。然而这样意味着我必须时常跟进<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>的更新。</p>

<p>顺带提一下这个协程库已经在我们线上服务器版本中使用了。</p>

<p>从最初的boost版本（我忘了从哪个版本开始了）一直到1.60版本，<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>的变化都不大，都只是补全一些新的架构和体系结构，还有就是修复一些小细节的BUG，再就是增加了对valgrind的支持（之前写过一个<a href="//owent.net/?p=1194">Merge记录</a>提到过）。新增的功能也只有<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html">execution_context</a>(现在叫execution_context_v1)，这个东西我的<a href="https://github.com/owt5008137/libcopp">libcopp</a>里其实包含了这个功能，并且本身做得比它要功能丰富，所以没有接入的必要。另外在1.60版本的时候尝试使用Windows里的fiber（当然默认是关闭的），在1.61版本里被移除了。这些细节都不是特别重要，主要还是1.61版本的变化。</p>

<p>然而这次变化就比较大了，首先所有的API都变更了，汇编代码里的参数和返回值也都发生了变化，当然语义也不一样了，另外还增加了新的API<strong>ontop_fcontext</strong>。这些变化使得<a href="https://github.com/owt5008137/libcopp">libcopp</a>的逻辑关系也必须有一些相应的调整，为了理清思路，这些都在后面分析。</p>

<h2 id="设计模型变化">设计模型变化</h2>

<h3 id="api变化">API变化</h3>

<p>先来看看原先的底层API</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">context</span> <span class="p">{</span>

<span class="cm">/**
 * @biref 执行环境上下文
 */</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span>   <span class="n">fcontext_t</span><span class="p">;</span>

<span class="cm">/**
 * @biref 跳转到目标上下文
 * @param ofc 当前的上下文会保存到ofc中
 * @param nfc 跳转到的目标上下文
 * @param vp 如果是第一次跳转，作为函数参数传入，如果是调回到jump_fcontext，这个是返回值
 * @param preserve_fpu 是否复制FPU（浮点数寄存器）数据
 * @return 如果调回时的透传参数
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="kt">intptr_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">fcontext_t</span> <span class="o">*</span> <span class="n">ofc</span><span class="p">,</span> <span class="n">fcontext_t</span> <span class="n">nfc</span><span class="p">,</span>
                                               <span class="kt">intptr_t</span> <span class="n">vp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preserve_fpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

<span class="cm">/**
 * @biref 初始化执行环境上下文
 * @param sp 栈空间地址
 * @param size 栈空间的大小
 * @param fn 入口函数
 * @return 返回初始化完成后的执行环境上下文
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="n">fcontext_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">make_fcontext</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">fn</span><span class="p">)(</span> <span class="kt">intptr_t</span><span class="p">)</span> <span class="p">);</span>

<span class="p">}}</span>
</code></pre>
</div>
<p>然后是现在的API</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">context</span> <span class="p">{</span>

<span class="cm">/**
 * @biref 执行环境上下文
 */</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span>   <span class="n">fcontext_t</span><span class="p">;</span>

<span class="cm">/**
 * @biref 跳转到目标上下文
 * @param ofc 当前的上下文会保存到ofc中
 * @param nfc 跳转到的目标上下文
 * @param vp 跳转到的目标上下文的附加参数。如果是第一次跳转，作为函数参数传入，如果是调回到jump_fcontext，这个是返回值
 * @param preserve_fpu 是否复制FPU（浮点数寄存器）数据
 * @return 如果调回时的透传参数
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="kt">intptr_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">fcontext_t</span> <span class="o">*</span> <span class="n">ofc</span><span class="p">,</span> <span class="n">fcontext_t</span> <span class="n">nfc</span><span class="p">,</span>
                                               <span class="kt">intptr_t</span> <span class="n">vp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preserve_fpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

<span class="cm">/**
 * @biref 初始化执行环境上下文
 * @param sp 栈空间地址
 * @param size 栈空间的大小
 * @param fn 入口函数
 * @return 返回初始化完成后的执行环境上下文
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="n">fcontext_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">make_fcontext</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">fn</span><span class="p">)(</span> <span class="kt">intptr_t</span><span class="p">)</span> <span class="p">);</span>

<span class="p">}}</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">context</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="cm">/**
 * @biref 执行环境上下文
 */</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span>   <span class="n">fcontext_t</span><span class="p">;</span>

<span class="cm">/**
 * @biref 事件参数包装
 */</span>
<span class="k">struct</span> <span class="n">transfer_t</span> <span class="p">{</span>
    <span class="n">fcontext_t</span>  <span class="n">fctx</span><span class="p">;</span> <span class="cm">/** 相关的的执行环境上下文-不同的API里含义不一样 **/</span>
    <span class="kt">void</span>    <span class="o">*</span>   <span class="n">data</span><span class="p">;</span> <span class="cm">/** 自定义数据 **/</span>
<span class="p">};</span>

<span class="cm">/**
 * @biref 跳转到目标上下文
 * @param to 当前的上下文会保存到ofc中
 * @param vp 跳转到的目标上下文的附加参数，会设置为transfer_t里的data成员
 * @return 跳转来源
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="n">transfer_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">fcontext_t</span> <span class="k">const</span> <span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">vp</span><span class="p">);</span>

<span class="cm">/**
 * @biref 初始化执行环境上下文
 * @param sp 栈空间地址
 * @param size 栈空间的大小
 * @param fn 入口函数
 * @return 返回初始化完成后的执行环境上下文
 */</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="n">fcontext_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">make_fcontext</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">fn</span><span class="p">)(</span> <span class="n">transfer_t</span><span class="p">)</span> <span class="p">);</span>

<span class="cm">/**
 * @biref 顶层跳转
 * @param to 当前的上下文会保存到ofc中
 * @param vp 跳转到的目标上下文的附加参数，会设置为transfer_t里的data成员
 * @param fn 入口函数，参数是跳转来源
 * @return 跳转来源
 */</span>
<span class="c1">// based on an idea of Giovanni Derreta
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="n">BOOST_CONTEXT_DECL</span>
<span class="n">transfer_t</span> <span class="n">BOOST_CONTEXT_CALLDECL</span> <span class="n">ontop_fcontext</span><span class="p">(</span> <span class="n">fcontext_t</span> <span class="k">const</span> <span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">vp</span><span class="p">,</span> <span class="n">transfer_t</span> <span class="p">(</span><span class="o">*</span> <span class="n">fn</span><span class="p">)(</span> <span class="n">transfer_t</span><span class="p">)</span> <span class="p">);</span>

<span class="p">}}}</span>

</code></pre>
</div>

<h3 id="流程变化">流程变化</h3>

<p>诸如命名空间从boost转移到boost::detail这种废话我就不说了，这也是说作者不再希望用户直接使用这些接口了。然而这挡不住我非要直接用，哈哈。</p>

<p>重要的是首先API参数和返回值变化，对于这些接口变更，boost里并没有文档，也没有什么地方有说明，所以目前我只能通过它的单元测试和sample来评估功能。</p>

<p>首先重要的是多一个<strong>transfer_t</strong>，这个里面的有两个对象，第一个<em>fctx</em>是来源的执行上下文，第二个<em>data</em>是各种接口传入的自定义的指针(上面接口里的<em>vp</em>)。<br />
来源的上下文指的是从什么位置跳转过来的。无论在回调参数还是各项返回值中都是这个含义。</p>

<p>对于<strong>make_fcontext</strong>这个接口，原先的入口函数是void (* fn)( intptr_t)，参数是透传自定义指针。现在是void (* fn)( transfer_t)，里面包含了来源执行栈的上下文和透传的自定义指针。</p>

<p>对于<strong>jump_fcontext</strong>这个接口，原先需要传入把当前执行上下文保存到哪里，跳转目标的新的上下文，自定义数据和是否复制FPU。<br />
现在的版本不再需要指定是否需要复制FPU了，同时也去除了自动保存当前上下文的功能，并且改成了跳到新的上下文后，新的上下文可以知道自己是从哪跳转过来的。</p>

<p>简单得说，原来比较像POSIX的<a href="http://linux.die.net/man/3/makecontext">makecontext</a>和<a href="http://linux.die.net/man/3/swapcontext">swapcontext</a>，现在做得事情更少了，功能拆分得更细，那么有些功能就得使用者来写。</p>

<p>另外，这次的<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>新增了一个比较有意思的接口，<strong>transfer_t ontop_fcontext( fcontext_t const to, void * vp, transfer_t (* fn)( transfer_t) )</strong>。<br />
这个接口的功能是在跳转目标(<em>to</em>指向的上下文)上模拟函数调用，并且返回值作为<strong>jump_fcontext</strong>的返回值，相当于可以给执行上下文接口打hook。举个例子：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code>
<span class="c1">// Step 1. 当前处于执行上下文-fctx1
</span><span class="n">transfer_t</span> <span class="n">jump_res</span> <span class="o">=</span> <span class="n">jump_fcontext</span><span class="p">(</span><span class="n">fctx2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// ...
// Step 2. 当前处于执行上下文-fctx2
// 跳入ontop_callback函数
</span><span class="n">ontop_fcontext</span><span class="p">(</span><span class="n">fctx1</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="n">ontop_callback</span><span class="p">);</span>

<span class="n">transfer_t</span> <span class="nf">ontop_callback</span><span class="p">(</span> <span class="n">transfer_t</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这时候 from.fctx == fctx2, from.data == 0x01
</span>    <span class="c1">// Step 3. 可以改变这些数据
</span>    <span class="n">from</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">from</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 这时候返回Step 1的
</span><span class="n">transfer_t</span> <span class="n">jump_res</span> <span class="o">=</span> <span class="n">jump_fcontext</span><span class="p">(</span><span class="n">fctx2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// Step 4. 这时候，jump_res.fctx == fctx2, from.data == 0x02
// continue other ...
</span>
</code></pre>
</div>

<p>这个功能比较有意思，<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv2.html"><em>execution_context_v2</em></a>里也使用它来完成初始化和跳转后的数据预处理。不过目前<a href="https://github.com/owt5008137/libcopp">libcopp</a>还没有地方需要用到它，以后有时间再想想这玩意在什么情况下需要用到，然后再加接口。</p>

<h3 id="向前兼容">向前兼容</h3>

<p>新的API不再像老的一样，跳转后会自动保存原来的上下文。所以在兼容之前的使用方法的时候，就需要手动来保存一下。<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>是使用了一个新的对象来记录调用者信息</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">data_t</span> <span class="p">{</span>
    <span class="n">activation_record</span>   <span class="o">*</span>   <span class="n">from</span><span class="p">;</span>
    <span class="kt">void</span>                <span class="o">*</span>   <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>那么<em>jump_fcontext</em>和<em>ontop_fcontext</em>的<em>vp</em>参数都是data_t*，然后每次跳入后保存调用来源的上下文</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// ========== 调用jump_fcontext ==========
// store current activation record in local variable
</span><span class="k">auto</span> <span class="n">from</span> <span class="o">=</span> <span class="n">current_rec</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// 这是一个TLS变量记录当前执行环境上下文
// store `this` in static, thread local pointer
// `this` will become the active (running) context
// returned by execution_context::current()
</span><span class="n">current_rec</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// 更新当前执行环境上下文
// 这一段是对GCC动态栈的支持
</span><span class="cp">#if defined(BOOST_USE_SEGMENTED_STACKS)
</span><span class="c1">// adjust segmented stack properties
</span><span class="n">__splitstack_getcontext</span><span class="p">(</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sctx</span><span class="p">.</span><span class="n">segments_ctx</span><span class="p">);</span>
<span class="n">__splitstack_setcontext</span><span class="p">(</span> <span class="n">sctx</span><span class="p">.</span><span class="n">segments_ctx</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="n">data_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="n">from</span><span class="p">,</span> <span class="n">vp</span> <span class="p">};</span> <span class="c1">// vp 是外部传入的private data
// context switch from parent context to `this`-context
</span><span class="n">transfer_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">fctx</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="n">data_t</span> <span class="o">*</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span> <span class="n">data_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="n">dp</span><span class="o">-&gt;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">fctx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">;</span> <span class="c1">// 保存来源上下文
</span>
<span class="c1">// ========== 通过jump_fcontext第一次跳入 ==========
// tampoline function
// entered if the execution context
// is resumed for the first time
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">AR</span> <span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">entry_func</span><span class="p">(</span> <span class="n">detail</span><span class="o">::</span><span class="n">transfer_t</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">data_t</span> <span class="o">*</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span> <span class="n">detail</span><span class="o">::</span><span class="n">data_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">AR</span> <span class="o">*</span> <span class="n">ar</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">AR</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">ar</span><span class="p">);</span>
    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">fctx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">;</span> <span class="c1">// 保存来源上下文
</span>    <span class="c1">// start execution of toplevel context-function
</span>    <span class="n">ar</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ========== 调用ontop_fcontext ==========
</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">Fn</span> <span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
<span class="n">data_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="p">};</span>
<span class="c1">// context switch from parent context to `this`-context
// execute Fn( Tpl) on top of `this`
</span><span class="n">transfer_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ontop_fcontext</span><span class="p">(</span> <span class="n">fctx</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">context_ontop</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;</span><span class="p">);</span>
<span class="n">data_t</span> <span class="o">*</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span> <span class="n">data_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="n">dp</span><span class="o">-&gt;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">fctx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">;</span> <span class="c1">// 保存来源上下文
</span>
<span class="c1">// ========== 通过ontop_fcontext跳入 ==========
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Fn</span> <span class="o">&gt;</span>
<span class="n">transfer_t</span> <span class="n">context_ontop</span><span class="p">(</span> <span class="n">transfer_t</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data_t</span> <span class="o">*</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span> <span class="n">data_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">fctx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">;</span> <span class="c1">// 保存来源上下文
</span>    <span class="k">auto</span> <span class="n">tpl</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">Fn</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">tpl</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">);</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span> <span class="n">fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span> <span class="n">data</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">,</span> <span class="n">dp</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<p>看上面的代码，基本上向前兼容的方法就是新搞一个data_t数据记录来源的<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html"><em>execution_context</em></a>的信息，透传过去后再把老的上下文保存进度。<br />
并且这么做之后，由于要有方式获取正在进行的上下文是哪一个，它有个记录当前执行上下文的TLS变量就变成了关键的东西。而这个TLS变量的问题后面会再提到。</p>

<h3 id="execution_context_v2">execution_context_v2</h3>

<p>新的boost.context提供了一个新版本的<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv2.html"><em>execution_context</em></a>对象，它其实是针对新的设计模型的一个执行上下文的抽象，并且粒度比以前的更小。所以你可以看到在性能比较的页面里v2版本的性能远高于v1。<br />
实际上性能高的原因是<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html">execution_context_v1</a>提供了有限的<a href="https://github.com/owt5008137/libcopp">libcopp</a>中coroutine提供的一部分功能，而<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv2.html"><em>execution_context_v2</em></a>则是把这些功能拆分地力度更小，作为其他模块的组件的时候更灵活。<br />
如果要使用<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv2.html"><em>execution_context_v2</em></a>的话，一些<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html">execution_context_v1</a>处理的问题还是必须上层框架再处理，所以单纯地比较切换速度意义不大。</p>

<p>另外新的<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv2.html"><em>execution_context_v2</em></a>更大规模地使用了C++11的特性，比如noexpect，右值，转移语义等等，用于提升性能。核心代码如下：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code>
<span class="cm">/** 参数包装 **/</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="p">...</span> <span class="o">&gt;</span>     <span class="n">args_tpl_t</span><span class="p">;</span>
<span class="cm">/** 返回值包装 **/</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">execution_context</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="p">...</span> <span class="o">&gt;</span>               <span class="n">ret_tpl_t</span><span class="p">;</span>

<span class="cm">/** 用于记录栈地址，入口函数和参数的对象 **/</span>
<span class="k">typedef</span> <span class="n">record</span><span class="o">&lt;</span> <span class="n">Ctx</span><span class="p">,</span> <span class="n">StackAlloc</span><span class="p">,</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">Params</span> <span class="p">...</span> <span class="o">&gt;</span>  <span class="n">record_t</span><span class="p">;</span>

<span class="c1">// ========== 调用jump_fcontext - context_create函数内 ==========
// create fast-context
</span><span class="k">const</span> <span class="n">fcontext_t</span> <span class="n">fctx</span> <span class="o">=</span> <span class="n">make_fcontext</span><span class="p">(</span> <span class="n">sp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">context_entry</span><span class="o">&lt;</span> <span class="n">record_t</span> <span class="o">&gt;</span><span class="p">);</span>
<span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">fctx</span><span class="p">);</span>
<span class="c1">// placment new for control structure on context-stack
</span><span class="k">auto</span> <span class="n">rec</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="p">(</span> <span class="n">sp</span><span class="p">)</span> <span class="n">record_t</span><span class="p">{</span>
        <span class="n">sctx</span><span class="p">,</span> <span class="n">salloc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">fn</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Params</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">params</span><span class="p">)</span> <span class="p">...</span> <span class="p">};</span>
<span class="c1">// transfer control structure to context-stack
</span><span class="k">return</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">fctx</span><span class="p">,</span> <span class="n">rec</span><span class="p">).</span><span class="n">fctx</span><span class="p">;</span>

<span class="c1">// ========== 调用jump_fcontext - ret_tpl_t operator()( Args ... args)函数内 ==========
</span><span class="n">ret_tpl_t</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">Args</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">fctx_</span><span class="p">);</span>
    <span class="n">args_tpl_t</span> <span class="n">data</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span><span class="p">)</span> <span class="p">...</span> <span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">transfer_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">detail</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span> <span class="n">fctx_</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">),</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="o">*</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">args_tpl_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_cat</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span> <span class="n">execution_context</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">)</span> <span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">data</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ========== 通过jump_fcontext第一次跳入 ==========
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Rec</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">context_entry</span><span class="p">(</span> <span class="n">transfer_t</span> <span class="n">t_</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// transfer control structure to the context-stack
</span>    <span class="n">Rec</span> <span class="o">*</span> <span class="n">rec</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">Rec</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t_</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">rec</span><span class="p">);</span>
    <span class="n">transfer_t</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// jump back to `context_create()`
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">jump_fcontext</span><span class="p">(</span> <span class="n">t_</span><span class="p">.</span><span class="n">fctx</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
        <span class="c1">// start executing
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span> <span class="n">t</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="n">forced_unwind</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">{</span> <span class="n">e</span><span class="p">.</span><span class="n">fctx</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">);</span>
    <span class="c1">// destroy context-stack of `this`context on next context
</span>    <span class="n">ontop_fcontext</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">context_exit</span><span class="o">&lt;</span> <span class="n">Rec</span> <span class="o">&gt;</span><span class="p">);</span>
    <span class="n">BOOST_ASSERT_MSG</span><span class="p">(</span> <span class="nb">false</span><span class="p">,</span> <span class="s">"context already terminated"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ========== 调用ontop_fcontext ==========
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Fn</span> <span class="o">&gt;</span>
<span class="n">ret_tpl_t</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">exec_ontop_arg_t</span><span class="p">,</span> <span class="n">Fn</span> <span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Args</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">fctx_</span><span class="p">);</span>
    <span class="n">args_tpl_t</span> <span class="n">data</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span><span class="p">)</span> <span class="p">...</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span> <span class="n">fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">data</span><span class="p">)</span> <span class="p">);</span>       <span class="c1">// 透传类型是 std::tuple&lt;Fn, args_tpl_t&gt;
</span>    <span class="n">detail</span><span class="o">::</span><span class="n">transfer_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">ontop_fcontext</span><span class="p">(</span>
            <span class="n">detail</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span> <span class="n">fctx_</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">),</span>              <span class="c1">// 跳入fctx_并把fctx_置空
</span>            <span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
            <span class="n">detail</span><span class="o">::</span><span class="n">context_ontop</span><span class="o">&lt;</span> <span class="n">execution_context</span><span class="p">,</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">Args</span> <span class="p">...</span> <span class="o">&gt;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="o">*</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">args_tpl_t</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_cat</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span> <span class="n">execution_context</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span><span class="p">)</span> <span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">data</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ========== 通过ontop_fcontext跳入 ==========
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Ctx</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fn</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<span class="n">transfer_t</span> <span class="n">context_ontop</span><span class="p">(</span> <span class="n">transfer_t</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">tpl</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BOOST_ASSERT</span><span class="p">(</span> <span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">tpl</span><span class="p">);</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Fn</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">auto</span> <span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">Ctx</span> <span class="n">ctx</span><span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">fctx</span> <span class="p">};</span>
    <span class="c1">// execute function
</span>    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span>                                <span class="c1">// apply的作用是展开并调用fn函数： fn(ctx, unpack(args))
</span>            <span class="n">fn</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tuple_cat</span><span class="p">(</span>
                <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">args</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">result</span><span class="p">)</span> <span class="p">);</span>
    <span class="c1">// apply returned data
</span>    <span class="n">detail</span><span class="o">::</span><span class="n">tail</span><span class="p">(</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">result</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">args</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">exchange</span><span class="p">(</span> <span class="n">ctx</span><span class="p">.</span><span class="n">fctx_</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">),</span> <span class="o">&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span> <span class="n">tpl</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="存在的问题">存在的问题</h2>
<p>我是不建议使用<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>的execution_context的。因为首先<a href="https://github.com/owt5008137/libcopp">libcopp</a>本身处理了它完成的功能，虽然它用模板写得，但是本身有一些兼容性问题。</p>

<p>比如TLS的问题，因为默认的Android和IOS标准库不支持TLS，而它里面大量使用<em>thread_local</em>关键字。首先不说非C++11的模式下没有这个关键字，即便有，在Android和IOS的默认标准库下也会link error。<br />
对于execution_context用TLS解决的问题，在<a href="https://github.com/owt5008137/libcopp">libcopp</a>里也同时存在，并且我也没想到什么好办法去解决（用pthread_create_key并不是特别理想），所以我现在的做法是，至少Android和IOS下单线程可用，多线程不支持<strong>copp::this_XXX</strong>功能。</p>

<h2 id="其他不是很重要的变化">其他不是很重要的变化</h2>
<p>这次的版本更新，<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>也有一些非关键性的变更。之所以说非关键是因为这些东西可有可没有，即便没有的话自己实现也不困难。列举如下:</p>

<ol>
  <li>pooled_fixedsize_stack，现在<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/index.html">boost.context</a>自己提供了一个用于分配栈空间的内存池。内部使用了侵入式智能指针，反正<a href="https://github.com/owt5008137/libcopp">libcopp</a>本身能够很容易实现这个，并且benchmark里本身就有使用预定内存池的例子，所以我认为这是非关键的功能。</li>
  <li>很多函数重新整理了一下，增加了noexpect/nothrow等。</li>
</ol>

<h2 id="libcopp的修订">libcopp的修订</h2>
<p>这次的merge，使用新的设计模型是必然的，但与此同时，我也会做一些细节的优化和调整。主要是下面几大块：</p>

<ol>
  <li><strong><em>优化</em></strong> 原来使用spin lock来处理多线程保护，还是抽象出跨平台且比较简单的原子操作类吧。好多时候想用但是因为麻烦直接用了c++11的atomic，但是这货gcc 4.4里没有。</li>
  <li><strong><em>更新</em></strong> 接入新API，类似<a href="http://www.boost.org/doc/libs/1_61_0/libs/context/doc/html/context/ecv1.html">execution_context_v1</a>的方式定义一个新的<strong>POD</strong>类型作为透传数据(必须是POD因为不会执行析构函数的)，跳转后处理保存来源的执行位置</li>
  <li><strong><em>更新</em></strong> 接入新API的话，跳转来源只能靠<em>this_coroutine</em>提供了。原先是对多线程且不支持TLS的环境不能使用<em>this_coroutine</em>，现在基础功能依赖它的话就必须保证其正确。那么计划是VC的话还是必须使用高版本（反正有社区版免费），GCC/Clang之流使用pthread处理TLS吧。</li>
  <li><strong><em>优化</em></strong> <em>coroutine</em>增加private data，然后<em>this_task</em>可以用<em>this_coroutine</em>关联，不需要两个TLS变量了，这是之前设计的一处小失误。这样<em>task</em>的多线程重入也可以用<em>coroutine</em>的。</li>
  <li><strong><em>更新</em></strong> caller应该要变为每次入口函数后初始化和不是来自yield的jump_to后更新。基本上caller只需要记录fcontext（支持GCC动态栈的情况下还需要多复制一个动态执行栈的数据），作用也只有执行完成后跳回。如果不是调用yield导致返回的，则是外部主动调用resume，所以结束时也需要返回到主动调用的地方。</li>
  <li><strong><em>更新</em></strong> start内的jump_to只能通过this_XXX来获取来源协程，yield内的jump_to的来源就是this。每次jump_to返回后都要更新来源协程的callee</li>
  <li><strong><em>更新</em></strong> this_XXX功能应该是入口函数处设置和jump_to执行返回后刷新（不能由外层记录old，因为可能发生变化）。起新的协程和yield都会走jump_to，同样start内得设为jump_to前的this_XXX，而yield的直接设为this</li>
  <li><strong><em>优化</em></strong> 接入cmake的WriteCompilerDetectionHeader并和<a href="https://github.com/atframework/atframe_utils">atframe_utils</a>保持一致，尽量加noexpect</li>
  <li><strong><em>优化</em></strong> 整理一下CI配置，同步<a href="https://github.com/atframework/libatbus">libatbus</a>的CI配置</li>
</ol>

<p>预计重构完成后性能不会有太大的改变，甚至因为更多地使用原子操作，可能导致性能还会变低一些。不过毕竟实际运用中并不需要经常做协程切换操作，而且逻辑的复杂度源超协程切换，所以关系不大。<br />
但是重构完后使用者更不容易出现错误，并且可以支持<strong>协程A跳转到协程B再跳转到协程A</strong>这种循环跳转，还是值得的。具体由多大变化，还是等重构完后看测试结果吧。</p>


				<hr />
				<footer class="page-footer">
					


<div class="author-image">
	<img src="/images/owner-logo.jpg" alt="owent">
</div><!-- ./author-image -->
<div class="author-content">
	<h3 class="author-name" >作者： <span itemprop="author">owent</span></h3>
	<p class="author-bio"></p>
</div><!-- ./author-content -->
					
<div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=boost.context-1.61版本的设计模型变化&amp;url=/article/2016-06-14/boost.context-1.61-design_change.html&amp;via=" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> 分享到 Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=/article/2016-06-14/boost.context-1.61-design_change.html" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> 分享到 Facebook</a>
	<a class="btn-social google-plus"  href="https://plus.google.com/share?url=/article/2016-06-14/boost.context-1.61-design_change.html" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> 分享到 Google+</a>
</div><!-- /.share-this -->

					

<div class="page-meta">
	<p>更新 <time datetime="2016-06-14T00:00:00Z" itemprop="datePublished">June 14, 2016</time></p>
</div><!-- /.page-meta -->
				</footer><!-- /.footer -->
				<aside>
					
				</aside>
			</div><!-- /.content -->
		</div><!-- /.inner-wrap -->
		
	</article><!-- ./wrap -->
</div><!-- /#main -->

      <footer role="contentinfo" id="site-footer">
	<nav role="navigation" class="menu bottom-menu">
		<ul class="menu-item">
		
      
			<li><a href="//atframe.work" >atframework home</a></li>
		
      
			<li><a href="//github.com/atframework" >github</a></li>
		
		</ul>
	</nav><!-- /.bottom-menu -->
	<p class="copyright">&#169; 2017 <a href="">atframework</a> powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> + <a href="http://mmistakes.github.io/skinny-bones-jekyll/" rel="nofollow">Skinny Bones</a>.</p>
</footer>
    </div>

    <script src="/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="/js/main.js"></script>

  </body>

</html>
