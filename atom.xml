<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.5">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-08-05T23:36:33+08:00</updated><id>/</id><title type="html">atframework</title><subtitle>Cloud server solution for game developer based atframework.</subtitle><entry><title type="html">libcopp v2的第一波优化完成</title><link href="/article/work/2017-07-01/1466.html" rel="alternate" type="text/html" title="libcopp v2的第一波优化完成" /><published>2017-07-01T23:57:29+08:00</published><updated>2017-07-01T23:57:29+08:00</updated><id>/article/work/2017-07-01/1466</id><content type="html" xml:base="/article/work/2017-07-01/1466.html">&lt;p&gt;之前测出来&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;还有一些列优化点，但是要破坏之前的API，所以整理了一下优化的想法和方案。&lt;/p&gt;

&lt;h2 id=&quot;预留空间和合并分配&quot;&gt;预留空间和合并分配&lt;/h2&gt;

&lt;p&gt;之前有太多的堆内存分配了，导致很多碎片。那么第一个想法就是协程对象可以分配在栈上，runner也可以分配在栈上。然后还可以加一个自定义预留长度。每个对象对齐到sizeof(long)，总长度对齐到64 Bytes。&lt;/p&gt;

&lt;p&gt;然后暴露出一个很小的足够编译优化时放进寄存器的对象，直接拷贝这个对象来传递协程（类似boost.context的continuation）。&lt;/p&gt;

&lt;p&gt;原来栈分配和协程对象分配是分开的，现在必须合并了。并且创建时可以指定分配多少预留空间。栈空间回收的操作必须切只能在析构结束最后执行，也就是智能指针的析构需要自己定义。&lt;/p&gt;

&lt;p&gt;仍然保留cotask和copp两个部分，但是cotask分配在copp的预留空间中，同样，action也分配在那里。结构如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;|......call stack(执行栈)........Xcotask(协程任务)...action(协程任务可执行对象)...copp(协程上下文对象)...private buffer(私有数据内存块)...随机偏移|
                                ^
                       执行栈起始地址从这里开始
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有数据都对齐到sizeof(&lt;a href=&quot;//en.cppreference.com/w/cpp/types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)或sizeof(long double)，即64位系统下对齐到8/16字节。&lt;/p&gt;

&lt;h2 id=&quot;侵入式智能指针&quot;&gt;侵入式智能指针&lt;/h2&gt;

&lt;p&gt;原来很多地方用得std::shared_ptr，这些也会导致额外的内存分配。这个目的本来是为了线程安全和生命周期管理，可以用make_shared来合并对象和管理区。如果我把协程对象分配在栈上，那就不能用make_shared了，那么内存碎片也就又出现了。所以我想再引入侵入式智能指针来解决这个问题。同时还可以选择要不要考虑线程安全，如果可以不考虑线程安全就可以节省掉原子操作的L1 cache miss的开销。&lt;/p&gt;

&lt;h2 id=&quot;关于缓存命中率和return-stack-buffer问题&quot;&gt;关于缓存命中率和return stack buffer问题&lt;/h2&gt;

&lt;p&gt;我和&lt;a href=&quot;https://github.com/yuanzhubi/call_in_stack&quot;&gt;call_in_stack&lt;/a&gt;的作者聊了聊，有不少收获。但是他使用的避免return stack buffer失效方法我感觉有点暴力了，直接重定义掉了ret的汇编指令。这种怕是跨架构并且和后面各种编译器行为和编译优化相关性都很强。虽然说效果很明显，但是我觉得还是要放弃这种实现。不过关于缓存命中率的问题倒是可以加入一个随机长度的栈起始offset来解决。现在很多CPU的L1 cache都是32KB，然后4-8路。所以保险点的话大约有64-128ways吧。反正如果是64的话，64和0是一样的，所以可以offset从&lt;em&gt;(0-127) « 3&lt;/em&gt;，然后就可以命中在不同的cache line上了。&lt;/p&gt;

&lt;p&gt;但是后来我测试的时候发现，其实在第一项优化之后，由于不同的cotask（包括其内部的协程上下文和task runner）的地址间隔比较远。导致&lt;strong&gt;&lt;em&gt;L1 Cache Read Miss&lt;/em&gt;&lt;/strong&gt;增高，反而实际切换开销增大了。但是实际使用过程中，协程内部的逻辑应该会更容易导致切换时的&lt;strong&gt;&lt;em&gt;L1 Cache Read Miss&lt;/em&gt;&lt;/strong&gt;，所以这个数值应该更具有参考意义。在这种情况下，那个带offset的减少cache miss的优化根本上没有效果，所以后来又去除了。&lt;/p&gt;

&lt;h2 id=&quot;减少原子操作&quot;&gt;减少原子操作&lt;/h2&gt;

&lt;p&gt;之前写&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt; merge boost 1.64和相关优化的blog里有提到这一点。主要是原子操作会导致cache miss。原来由于是用智能指针来维护生命周期，很容易传递这个协程的时候发生原子操作，另外就是每次切换上下文前，由于要检查状态，都避免不了一次load、一次CAS和一次restore。然后cotask要做一次这个操作，copp也要做一次。然后在当时的测试里，使用的是栈池，而栈池为了保证线程安全，又有一次splin lock的加锁和解锁。这导致cotask的开销比copp多了40+ns。而精简的情况下，协程操作才70ns左右。这就增加了非常多了。&lt;/p&gt;

&lt;p&gt;所以减少原子操作，一方面是要简化cotask和copp里的两次，可以优化成一次。另外可以开启一个非线程安全选项，这时候吧原子整数换成普通整数。因为我们游戏进程里都是单线程的服务，这种开销也不需要。&lt;/p&gt;

&lt;h2 id=&quot;右值引用&quot;&gt;右值引用&lt;/h2&gt;

&lt;p&gt;本来大部分逻辑是可以用简单的方法，无视掉低量的复制消耗的。但是随着原子操作的消耗增加，我们就不得不注意类似智能指针复制导致的这种原子开销。所以就得更加智能地判定编译器并且使用右值，因为使用右值转移智能指针的话，不涉及计数器的增减，所以也就没有这个开销。&lt;/p&gt;

&lt;p&gt;其他方面使用右值倒不是特别重要，因为传递的东西几乎都是只有几个指针的长度，很容易在编译优化的时候放进寄存器。这样就很快了。&lt;/p&gt;

&lt;h2 id=&quot;新的单元测试&quot;&gt;新的单元测试&lt;/h2&gt;

&lt;p&gt;结构的变化必然涉及新的单元测试用例，我稍微列举了下，记在这里以便后续一个一个地实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;private buffer边界和内容测试&lt;/li&gt;
  &lt;li&gt;支持区分task_action_impl和非task_action_impl的仿函数，并且测试on_finished接口的是否被正确调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;api调整&quot;&gt;API调整&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;移除了不含参数的callback支持，现在所有的托管回掉的形式都是 int (void*)。（以前接入新模型后向前兼容地保留了int ()的接口，这次涉及接口调整，所以一起移除了这个历史包袱）&lt;/li&gt;
  &lt;li&gt;不再允许把协程对象声明在栈上，现在必须分配在栈上，并且使用侵入式智能指针&lt;/li&gt;
  &lt;li&gt;协程任务系统使用侵入式智能指针，不再使用shared_ptr&lt;/li&gt;
  &lt;li&gt;不再支持共享task action，实际应用中没什么作用&lt;/li&gt;
  &lt;li&gt;允许预定义分配一段私有数据空间，保存用户数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;初步成果&quot;&gt;初步成果&lt;/h2&gt;

&lt;p&gt;目前v2版本的基本改造和流程已经实现完毕，CI上的结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;###################### context coroutine (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_coroutine_stack_pool 1000 1000 2048
### Round: 1 ###
allocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1000 coroutine, cost time: 0 s, clock time: 5 ms, avg: 5000 ns
switch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 83 ms, avg: 83 ns
remove 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 2 ###
allocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 82 ms, avg: 82 ns
remove 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 3 ###
allocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 83 ms, avg: 83 ns
remove 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 4 ###
allocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 82 ms, avg: 82 ns
remove 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 5 ###
allocate 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 coroutine contest 1000000 times, cost time: 0 s, clock time: 83 ms, avg: 83 ns
remove 1000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns


###################### context coroutine (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_coroutine_stack_pool 1 3000000 16
### Round: 1 ###
allocate 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 coroutine contest 3000000 times, cost time: 0 s, clock time: 162 ms, avg: 54 ns
remove 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 2 ###
allocate 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 coroutine contest 3000000 times, cost time: 1 s, clock time: 162 ms, avg: 54 ns
remove 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 3 ###
allocate 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 coroutine contest 3000000 times, cost time: 0 s, clock time: 162 ms, avg: 54 ns
remove 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 4 ###
allocate 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 coroutine contest 3000000 times, cost time: 0 s, clock time: 163 ms, avg: 54 ns
remove 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 5 ###
allocate 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 coroutine contest 3000000 times, cost time: 0 s, clock time: 163 ms, avg: 54 ns
remove 1 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns


###################### context coroutine (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_coroutine_stack_pool 30000 100 64
### Round: 1 ###
allocate 30000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 30000 coroutine, cost time: 0 s, clock time: 145 ms, avg: 4833 ns
switch 30000 coroutine contest 3000000 times, cost time: 1 s, clock time: 771 ms, avg: 257 ns
remove 30000 coroutine, cost time: 0 s, clock time: 6 ms, avg: 200 ns
### Round: 2 ###
allocate 30000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 30000 coroutine, cost time: 0 s, clock time: 10 ms, avg: 333 ns
switch 30000 coroutine contest 3000000 times, cost time: 1 s, clock time: 812 ms, avg: 270 ns
remove 30000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 133 ns
### Round: 3 ###
allocate 30000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 30000 coroutine, cost time: 0 s, clock time: 9 ms, avg: 300 ns
switch 30000 coroutine contest 3000000 times, cost time: 1 s, clock time: 793 ms, avg: 264 ns
remove 30000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 133 ns
### Round: 4 ###
allocate 30000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 30000 coroutine, cost time: 0 s, clock time: 9 ms, avg: 300 ns
switch 30000 coroutine contest 3000000 times, cost time: 0 s, clock time: 787 ms, avg: 262 ns
remove 30000 coroutine, cost time: 0 s, clock time: 5 ms, avg: 166 ns
### Round: 5 ###
allocate 30000 coroutine, cost time: 0 s, clock time: 0 ms, avg: 0 ns
create 30000 coroutine, cost time: 0 s, clock time: 9 ms, avg: 300 ns
switch 30000 coroutine contest 3000000 times, cost time: 1 s, clock time: 804 ms, avg: 268 ns
remove 30000 coroutine, cost time: 0 s, clock time: 4 ms, avg: 133 ns


###################### task (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_task_stack_pool 1000 1000 2048
### Round: 1 ###
create 1000 task, cost time: 0 s, clock time: 5 ms, avg: 5000 ns
switch 1000 tasks 1000000 times, cost time: 0 s, clock time: 160 ms, avg: 160 ns
remove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 2 ###
create 1000 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 tasks 1000000 times, cost time: 0 s, clock time: 160 ms, avg: 160 ns
remove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 3 ###
create 1000 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 tasks 1000000 times, cost time: 0 s, clock time: 160 ms, avg: 160 ns
remove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 4 ###
create 1000 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 tasks 1000000 times, cost time: 0 s, clock time: 159 ms, avg: 159 ns
remove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 5 ###
create 1000 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1000 tasks 1000000 times, cost time: 0 s, clock time: 160 ms, avg: 160 ns
remove 1000 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns


###################### task (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_task_stack_pool 1 3000000 16
### Round: 1 ###
create 1 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 tasks 3000000 times, cost time: 1 s, clock time: 351 ms, avg: 117 ns
remove 1 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 2 ###
create 1 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 tasks 3000000 times, cost time: 0 s, clock time: 347 ms, avg: 115 ns
remove 1 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 3 ###
create 1 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 tasks 3000000 times, cost time: 0 s, clock time: 346 ms, avg: 115 ns
remove 1 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 4 ###
create 1 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 tasks 3000000 times, cost time: 1 s, clock time: 346 ms, avg: 115 ns
remove 1 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns
### Round: 5 ###
create 1 task, cost time: 0 s, clock time: 0 ms, avg: 0 ns
switch 1 tasks 3000000 times, cost time: 0 s, clock time: 346 ms, avg: 115 ns
remove 1 tasks, cost time: 0 s, clock time: 0 ms, avg: 0 ns


###################### task (stack using stack pool) ###################
########## Cmd: ./sample_benchmark_task_stack_pool 30000 100 64
### Round: 1 ###
create 30000 task, cost time: 1 s, clock time: 150 ms, avg: 5000 ns
switch 30000 tasks 3000000 times, cost time: 1 s, clock time: 1407 ms, avg: 469 ns
remove 30000 tasks, cost time: 0 s, clock time: 13 ms, avg: 433 ns
### Round: 2 ###
create 30000 task, cost time: 0 s, clock time: 14 ms, avg: 466 ns
switch 30000 tasks 3000000 times, cost time: 1 s, clock time: 1404 ms, avg: 468 ns
remove 30000 tasks, cost time: 0 s, clock time: 13 ms, avg: 433 ns
### Round: 3 ###
create 30000 task, cost time: 0 s, clock time: 14 ms, avg: 466 ns
switch 30000 tasks 3000000 times, cost time: 2 s, clock time: 1420 ms, avg: 473 ns
remove 30000 tasks, cost time: 0 s, clock time: 14 ms, avg: 466 ns
### Round: 4 ###
create 30000 task, cost time: 0 s, clock time: 16 ms, avg: 533 ns
switch 30000 tasks 3000000 times, cost time: 1 s, clock time: 1419 ms, avg: 473 ns
remove 30000 tasks, cost time: 0 s, clock time: 13 ms, avg: 433 ns
### Round: 5 ###
create 30000 task, cost time: 0 s, clock time: 14 ms, avg: 466 ns
switch 30000 tasks 3000000 times, cost time: 2 s, clock time: 1389 ms, avg: 463 ns
remove 30000 tasks, cost time: 0 s, clock time: 13 ms, avg: 433 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是CI里Linux上的结果，osx和windows上的结果就不贴了，都没linux上的数据好，不过相差不大。&lt;/p&gt;

&lt;p&gt;这一批优化过后，其实切换性能并没有提高，反而下降了，我查了一下是原先对read的L1 cache命中率也比较高，但是现在下降了。不过我认为这种miss的情况可能更能说明问题，因为现在是几乎0逻辑，一旦有逻辑之后也容易增加cache miss。究其原因，应该是新的组织方式把一个协程（特别是task）的维护数据放在了栈上，那么切换的时候切换地址就会比较遥远。而之前的方式，只要多个协程对象靠得近，而协程对象又足够小（task对象里的数据比较大，但是coroutine里的比较小），因为只有压测代码，所以new的时候malloc一般会把类似大小的对象放一起，这也增加了命中率。但是实际应用的话，必然中间会插入很多其他对象的，所以这个情况也会不贴近实际场景。但是另一方面，v2的优化也使得在使用栈池的情况下，分配开销被大幅降低了，我们的项目里由于开始需要大量的定时器，定时器回调的时候也需要在协程内进行，这也给大量定时器的触发的时候提供了更好的支持和保障。&lt;/p&gt;

&lt;p&gt;不过我认为现在的v2任然有可以再优化的地方，本来想在优化完一波再放出这篇总结，但是一方面还没找到什么特别好的不破坏设计的点。另一方面最近看了下SSR-libev的源码，觉得他那种方式的适配的扩展性更好，所以后面可能回去优化服务器框架&lt;a href=&quot;https://github.com/atframework/atsf4g-co&quot;&gt;asf4g-co&lt;/a&gt;的网关层部分，可能要有比较大的改动，改变密钥协商流程，让atgateway支持协商加密方式、更多的加密算法和支持椭圆双曲线协商。所以&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的优化暂时搁置吧，不过以后会主要以v2版本的api为准，基本不会再变更接口了吧。&lt;/p&gt;</content><author><name></name></author><category term="coroutine" /><category term="cpp" /><category term="g++" /><category term="gcc" /><category term="go" /><category term="goroutine" /><category term="libcopp" /><category term="协程" /><summary type="html">之前测出来libcopp还有一些列优化点，但是要破坏之前的API，所以整理了一下优化的想法和方案。</summary></entry><entry><title type="html">libcopp(v2) vs goroutine性能测试</title><link href="/article/work/2017-06-10/1465.html" rel="alternate" type="text/html" title="libcopp(v2) vs goroutine性能测试" /><published>2017-06-10T23:57:29+08:00</published><updated>2017-06-10T23:57:29+08:00</updated><id>/article/work/2017-06-10/1465</id><content type="html" xml:base="/article/work/2017-06-10/1465.html">&lt;p&gt;本来是没想写这个对比。无奈之前和&lt;a href=&quot;https://github.com/yuanzhubi/call_in_stack&quot;&gt;call_in_stack&lt;/a&gt;的作者聊了一阵，发现了一些&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的改进空间。然后顺便看了新的boost.context的cc部分的代码，有所启发。想给&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;做一些优化，主要集中在减少分配次数从而减少内存碎片；在支持的编译器里有些地方用右值引用来减少不必要的拷贝；减少原子操作和减少L1cache miss几个方面。&lt;/p&gt;

&lt;p&gt;之后改造了茫茫多流程和接口后出了v2版本，虽然没完全优化完，但是组织结构已经定型了，可以用来做压力测试。为了以后方便顺便还把cppcheck和clang-analyzer的静态分析工具写进了dev脚本。然后万万没想到的是，在大量协程的情况下，benchmark的结果性能居然比原来还下降了大约1/3。&lt;/p&gt;

&lt;p&gt;我结合valgrind和perf的报告分析了一下原因，原来的读L1 cache miss大约在68%左右，而v2里的读L1 cache miss到了98%。究其原因，原来的协程、协程任务对象和协程任务的actor是由malloc分配的，而现在在v2里全部优化后放进了分配的执行栈里。这样减少了三次malloc操作。但是这也导致不同协程、任务和actor之间的距离隔得非常远，必超出L1 cache的量（一般是64字节）。那么就必然容易L1 cache miss了。而原来在benchmark里由于是连续分配的，所以他们互相都在比较近的位置，当然原来的性能高了。&lt;/p&gt;

&lt;p&gt;这种情况，因该说是原来的benchmark更加不能作为实际使用过程中的性能参考依据。之前也说过，因为在实际应用场景中几乎必然cache miss，因为逻辑会更复杂得多，内存访问也更切换得频繁和多。&lt;/p&gt;

&lt;p&gt;这让我突然想到了&lt;a href=&quot;https://golang.org&quot;&gt;go&lt;/a&gt;语言的goroutine。不知道这玩意有没有考虑切换时的Cache miss开销，不知道针对这个做优化。因为它是语言级别实现的go程，那么如果要针对缓存做优化则比较容易实现一些。不过它的动态栈总归会有一定的开销。&lt;/p&gt;

&lt;h2 id=&quot;goroutine压力测试&quot;&gt;goroutine压力测试&lt;/h2&gt;

&lt;p&gt;这里还是用了和&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;里差不多的测试方法。benchmark的代码如下:&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;os&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;strconv&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switchTimes&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;##### Round: %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsOut&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsOut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Create %v goroutines and channels cost %vns, avg %vns&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsOut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Start %v goroutines and channels cost %vns, avg %vns&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switchTimes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
			&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
			&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsOut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Switch %v goroutines for %v times cost %vns, avg %vns&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelsOut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Close %v goroutines cost %vns, avg %vns&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nanoseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switchTimes&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;30000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;### Run: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switchTimes&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switchTimes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同时发布在了： https://gist.github.com/owt5008137/2286768f2586521600c9fd1700cbf845&lt;/p&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS D:\projs\test\go&amp;gt; .\test_goroutine.exe
### Run:  &quot;D:\projs\test\go\test_goroutine.exe&quot;
##### Round: 1
Create 30000 goroutines and channels cost 6515200ns, avg 217ns
Start 30000 goroutines and channels cost 79505000ns, avg 2650ns
Switch 30000 goroutines for 30000000 times cost 42225426300ns, avg 1407ns
Close 30000 goroutines cost 15017500ns, avg 500ns
##### Round: 2
Create 30000 goroutines and channels cost 19868200ns, avg 662ns
Start 30000 goroutines and channels cost 22487700ns, avg 749ns
Switch 30000 goroutines for 30000000 times cost 44709165100ns, avg 1490ns
Close 30000 goroutines cost 15559000ns, avg 518ns
##### Round: 3
Create 30000 goroutines and channels cost 3999700ns, avg 133ns
Start 30000 goroutines and channels cost 17508400ns, avg 583ns
Switch 30000 goroutines for 30000000 times cost 50535999000ns, avg 1684ns
Close 30000 goroutines cost 36289900ns, avg 1209ns
##### Round: 4
Create 30000 goroutines and channels cost 5999600ns, avg 199ns
Start 30000 goroutines and channels cost 44500300ns, avg 1483ns
Switch 30000 goroutines for 30000000 times cost 45678842800ns, avg 1522ns
Close 30000 goroutines cost 13005600ns, avg 433ns
##### Round: 5
Create 30000 goroutines and channels cost 5000000ns, avg 166ns
Start 30000 goroutines and channels cost 14001000ns, avg 466ns
Switch 30000 goroutines for 30000000 times cost 47485810100ns, avg 1582ns
Close 30000 goroutines cost 17999800ns, avg 599ns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里都是在我家里的Windows机器下跑的结果，在Linux下应该性能能够更好一些，因为我家里的机器比较渣，并且&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;在Linux下性能就比在Windows下好得多。那么为了对比，还需要同样在这台机器下，同样环境的&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的测试结果。&lt;/p&gt;

&lt;p&gt;这里用的是go语言推荐的协程间共享数据的方式，应该是最贴近&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的流程了。这里面可以看出来创建chan需要的开销并不大，但是其实goroutine的切换开销还是蛮大的，基本上都要超过1us。而且感觉go语言内部还是维护了goroutine的池子，不然创建开销抖动不会那么大。&lt;/p&gt;

&lt;p&gt;不过goroutine的内存开销确实小，30000个goroutine的内存占用才300MB。&lt;/p&gt;

&lt;h2 id=&quot;libcopp的同环境报告和对比&quot;&gt;&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的同环境报告和对比&lt;/h2&gt;

&lt;p&gt;我只贴一样的协程数量和切换次数的结果了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ###################### task (stack using stack pool) ###################
  ########## Cmd: .\sample_benchmark_task_stack_pool.exe 30000 1000 64
  ### Round: 1 ###
  create 30000 task, cost time: 0 s, clock time: 104 ms, avg: 3466 ns
  switch 30000 tasks 30000000 times, cost time: 18 s, clock time: 18500 ms, avg: 616 ns
  remove 30000 tasks, cost time: 0 s, clock time: 28 ms, avg: 933 ns
  ### Round: 2 ###
  create 30000 task, cost time: 0 s, clock time: 44 ms, avg: 1466 ns
  switch 30000 tasks 30000000 times, cost time: 19 s, clock time: 18341 ms, avg: 611 ns
  remove 30000 tasks, cost time: 0 s, clock time: 29 ms, avg: 966 ns
  ### Round: 3 ###
  create 30000 task, cost time: 0 s, clock time: 44 ms, avg: 1466 ns
  switch 30000 tasks 30000000 times, cost time: 18 s, clock time: 18188 ms, avg: 606 ns
  remove 30000 tasks, cost time: 0 s, clock time: 28 ms, avg: 933 ns
  ### Round: 4 ###
  create 30000 task, cost time: 0 s, clock time: 44 ms, avg: 1466 ns
  switch 30000 tasks 30000000 times, cost time: 18 s, clock time: 18267 ms, avg: 608 ns
  remove 30000 tasks, cost time: 0 s, clock time: 28 ms, avg: 933 ns
  ### Round: 5 ###
  create 30000 task, cost time: 0 s, clock time: 44 ms, avg: 1466 ns
  switch 30000 tasks 30000000 times, cost time: 19 s, clock time: 18772 ms, avg: 625 ns
  remove 30000 tasks, cost time: 0 s, clock time: 26 ms, avg: 866 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样对比下，&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的切换开销就小的多了，而且比较稳定，但是创建开销也是比较大，特别是第一次要分配栈的情况下（后面都会使用栈池机制，减少系统调用所以会小很多）。&lt;/p&gt;

&lt;p&gt;其实这是v2的测试数据，虽然切换开销比原来是要大一些，但是之前在Linux上的结果，这个创建开销已经是原来版本的一半了（Linux上的创建开销原先大约是1us，v2大约是500ns，切换开销忘记了，v2版本大约是300-400ns）。&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;go语言现在很火了，性能超过goroutine的话肯定是已经有实用价值了，特别是逻辑开销很容易就能抹平这个协程的开销。而且go语言本来还就是目标于高性能分布式系统的，并且很多这种分布式系统的一些逻辑可能并不特别重，都能容忍这个开销，何况&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;呢。但是&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的v2版本细节上仍然还有一些优化点，比如内存布局和原子操作必导致L1 Cache失效的问题等等。等我一并处理完再merge回master。现在还是放在https://github.com/owt5008137/libcopp的v2分支里。&lt;/p&gt;

&lt;p&gt;当然哪位大神有更好的建议希望能够不吝赐教。之前针对缓存优化的点，其实优化好了跑分会很好看，但是实用性上还得分场景。像&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的定位是比较重量级的场景，能够覆盖比较完整而且复杂的协程流程和逻辑，对于比较复杂的场景（比如我们游戏里），那些缓存优化就没太大意义。而对于那些简单的只是用来临时做上下文切换而且不要求跨平台跨编译器的，我还是建议使用类似&lt;a href=&quot;https://github.com/yuanzhubi/call_in_stack&quot;&gt;call_in_stack&lt;/a&gt;这种轻量级的库，毕竟性能搞了一个数量级。&lt;/p&gt;</content><author><name></name></author><category term="coroutine" /><category term="cpp" /><category term="g++" /><category term="gcc" /><category term="go" /><category term="goroutine" /><category term="libcopp" /><category term="协程" /><summary type="html">本来是没想写这个对比。无奈之前和call_in_stack的作者聊了一阵，发现了一些libcopp的改进空间。然后顺便看了新的boost.context的cc部分的代码，有所启发。想给libcopp做一些优化，主要集中在减少分配次数从而减少内存碎片；在支持的编译器里有些地方用右值引用来减少不必要的拷贝；减少原子操作和减少L1cache miss几个方面。</summary></entry><entry><title type="html">libcopp的线程安全、栈池和merge boost.context 1.64.0</title><link href="/article/blablabla/2017-05-12/1446.html" rel="alternate" type="text/html" title="libcopp的线程安全、栈池和merge boost.context 1.64.0" /><published>2017-05-13T03:45:17+08:00</published><updated>2017-05-13T03:45:17+08:00</updated><id>/article/blablabla/2017-05-12/1446</id><content type="html" xml:base="/article/blablabla/2017-05-12/1446.html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;线程安全&quot;&gt;线程安全&lt;/h2&gt;

&lt;p&gt;前段时间看到了一个完成读比较高的协程库-&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;，里面提供了线程安全的协程实现，并且也是使用锁。本来我并没有给&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;里的功能加锁的打算，因为上层dispatcher还是比较容易做到安全分发的，所以原来并不保证线程安全。而且线程安全这种问题单元测试比较难写，可能还得碰点运气。但是思来想去，还是为线程安全做点什么吧。反正也不是很复杂。&lt;/p&gt;

&lt;p&gt;由于我并没有给utils加互斥锁的跨平台适配，所以先就直接用了自旋锁，来锁住需要考虑线程安全的地方。其实需要加锁的地方并不多，无非是管理器的增删查和task的next函数需要加锁。这些逻辑都很短，功能也很简单，并不会占用太多时间，所以自旋锁的问题也不大。而且以后真发现有问题，换掉也不是什么难事儿。&lt;/p&gt;

&lt;h2 id=&quot;栈池和协程任务管理器&quot;&gt;栈池和协程任务管理器&lt;/h2&gt;

&lt;p&gt;前段时间发现我的压力测试代码有问题。之前测出来使用内存池来做栈的创建开销和直接malloc或者mmap的性能差不多，所以一致没有做池子的功能。但是后来发现其实CPU耗在了缺页中断上面。于是尝试消除掉缺页中断的影响，然后发现创建性能提升了10倍。&lt;/p&gt;

&lt;p&gt;这样的话，栈池就变得有意义了，而且由于我们新游戏是走得MMO路线，而这里异步操作比较多，也比较频繁，而且还有定时器恢复的时候也要重新进入协程。所以这个创建开销还是蛮重要的。原来一次协程创建大约需要8us，意味着QPS只有大约10W。现在缩减到300ns了，可以到300W，和一次协程切换差不太多，这样的话协程的开销就可以几乎忽略了，因为剩下的逻辑很难低于这个开销。另外栈池使用模板实现了，因为希望能够自定义池子里没有对象时的分配策略，并且能使用之前的栈分配器。所以模板的参数就是原来的分配器的类型。&lt;/p&gt;

&lt;h2 id=&quot;boostcontext&quot;&gt;boost.context&lt;/h2&gt;

&lt;p&gt;boost 1.64发布了，所以顺便merge一下&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt; 1.64版本。但是这次merge的时候我看了下&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的汇编代码，让我对boost的代码质量开始表示怀疑了。&lt;/p&gt;

&lt;p&gt;在merge boost.context 1.63之后，我这里libcopp的单元测试在MinGW下会崩溃。但是由于目前我这里没有在使用MinGW的环境作为开发所以并没有太在意。&lt;/p&gt;

&lt;p&gt;然后这次的merge里我看到的CHANGELOG里有关于MinGW的修复，所以就去看了下他改了什么，结果发现其实是一个非常2B的错误（写错了一个寄存器名字）。&lt;/p&gt;

&lt;p&gt;这种很容易发现的问题，竟然进入了Release里。这至少说明&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的单元测试覆盖本身就很有问题，或者说单元测试没过竟然就发布了。以后merge的时候还是得review一遍他的代码。&lt;/p&gt;

&lt;p&gt;有一个重要的变化（虽然&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;里并没有用到），废弃了execution_context。我&lt;a href=&quot;https://www.owent.net/2016/1270.html#存在的问题&quot;&gt;之前就提到过&lt;/a&gt;，这个东西的设计很有诸多问题，功能和&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;里的coroutine_container差不多，果然现在被废弃了。估计有使用这个的人或者其他库会挺伤的吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;移除了coroutine_container，所以加了个一个更细粒度的API: &lt;strong&gt;callcc&lt;/strong&gt;和&lt;strong&gt;continuation&lt;/strong&gt;。这组API的实现的特点大致上如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认使用&lt;strong&gt;fixedsize_stack&lt;/strong&gt;(posix下使用&lt;strong&gt;&lt;em&gt;malloc&lt;/em&gt;&lt;/strong&gt;，windows下使用&lt;strong&gt;&lt;em&gt;VirtualAlloc&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;依赖C++11右值语义来进行资源转移&lt;/li&gt;
  &lt;li&gt;由&lt;strong&gt;continuation&lt;/strong&gt;保存fcontext&lt;/li&gt;
  &lt;li&gt;栈空间的前一部分用于保存执行上下文&lt;strong&gt;Record&lt;/strong&gt;(对齐到64字节)，后面跟执行栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论是&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;还是我的&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;，都使用std::function作为回调委托。然而std::function底层如果绑定的是仿函数或者lambda表达式，就避免不了new操作。那么完全避免new的意义就不是很大。&lt;/p&gt;

&lt;p&gt;所以&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;仍然使用智能指针维护协程上下文。&lt;/p&gt;

&lt;h2 id=&quot;性能优化&quot;&gt;性能优化&lt;/h2&gt;

&lt;p&gt;一开始看到&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;的时候，发现它比&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;快一些。但是因为底层都是&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;，所以按理来说不会有太大差别。起初测试的时候用的是-O2，后来发现&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;使用-O3编译的效果，性能就和&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;（因为&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;的CI里配置的是使用-O3）接近了。即便是这样，我后来还是发现&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;能有一些优化空间。所以这次优化先是把自己构造shared_ptr改成了make_shared，来减少内存碎片。这个优化之后，&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的-O2也能有&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;的-O3相近的性能了。&lt;/p&gt;

&lt;p&gt;最近还看到另一个库&lt;a href=&quot;https://github.com/yuanzhubi/call_in_stack&quot;&gt;call_in_stack&lt;/a&gt;，作者说是创建栈的时候不要对齐到4KB，这样能减少分支预测的cache miss，能大幅提高协程效率，我这里拿最简单的切换测试了一下不对齐的栈空间的切换开销大约是20ns，即便在对齐的情况下也只有80ns。十分NB，不过这些测试都是没有栈和协程管理开销的情况下，裸的切换开销。我打算过段时间也去研究下这个。术语好像叫&lt;em&gt;stride access&lt;/em&gt;，还有一个是辅助函数返回预测的，http://en.wikipedia.org/wiki/Branch_predictor#Prediction_of_function_returns 里有描述，等有空我也要研究下。而且他这个库并没有考虑线程安全、资源管理之类的东西，还需要额外的实现。而我们游戏中使用协程其实很容易cache miss的。因为逻辑必然比协程切换要复杂，几乎必然cache miss。所以我这里的压力测试结果和&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;差不太多，比它稍微好一些。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的新API，call/cc把context存在了分配的栈里，然后一64字节对齐加了offset，不清楚对这个缓存命中和分支预测是否有影响。所以顺便测试了一下。简要的说，测试结果是：-O2优化的情况下，创建boost::context::continuation的开销大约是330ns，协程切换开销大约是60-70ns。而如果只开启一个协程栈，切换开销只要14ns。这个性能大约是&lt;a href=&quot;https://github.com/yuanzhubi/call_in_stack&quot;&gt;call_in_stack&lt;/a&gt;的一半，但是兼容性要好多了。&lt;br /&gt;
测试代码及测试结果见： https://gist.github.com/owt5008137/110a4f73dd8def89e98d4cd66a0b8260&lt;/p&gt;

&lt;p&gt;接下来是&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt; profile结果:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;简报: &lt;em&gt;-O2情况下，使用栈池的创建开销约250ns。低cache miss协程切换约需要70ns，高cache miss需要约200ns，同时协程任务和action的维护代价约是40-50ns&lt;/em&gt;。也就是说如果使用完整的协程任务+栈池。那么实际场景中的切换开销约250ns。简要的profile如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;协程上下文切换&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Samples: 169K of event 'cpu-clock', Event count (approx.): 42282500000
  Children      Self  Command          Shared Object                          Symbol                                                                                          
+   68.13%    68.12%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp_jump_fcontext
+   18.56%     0.00%  sample_benchmar  [unknown]                              [.] 0000000000000000
+   18.48%     0.00%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp::detail::coroutine_context_container&amp;lt;copp::detail::coroutine_context_base, copp::allocator::stack_all
+   18.48%     0.00%  sample_benchmar  [unknown]                              [k] 0xec83485355544155
+    8.58%     8.58%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp::detail::coroutine_context_base::yield
+    7.52%     7.52%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp::detail::coroutine_context_base::start
+    5.32%     5.32%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp::detail::coroutine_context_base::jump_to
+    4.64%     4.64%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] main
+    3.55%     3.55%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] my_runner::operator()
+    1.11%     1.11%  sample_benchmar  sample_benchmark_coroutine_stack_pool  [.] copp::detail::coroutine_context_base::is_finished
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;协程任务切换&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Samples: 211K of event 'cpu-clock', Event count (approx.): 52831500000
  Children      Self  Command          Shared Object                     Symbol
+   51.24%    51.19%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp_jump_fcontext
+   15.25%     0.00%  sample_benchmar  [unknown]                         [.] 0xec83485355544155
+   15.25%     0.00%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::task&amp;lt;my_macro_coroutine, my_macro_task&amp;gt;::~task
+    8.14%     8.14%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::impl::task_impl::_cas_status
+    7.82%     7.81%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp::detail::coroutine_context_base::yield
+    6.35%     6.34%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp::detail::coroutine_context_base::jump_to
+    6.14%     6.13%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp::detail::coroutine_context_base::start
+    4.53%     4.52%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::task&amp;lt;my_macro_coroutine, my_macro_task&amp;gt;::start
+    4.02%     4.01%  sample_benchmar  sample_benchmark_task_stack_pool  [.] main
+    3.11%     3.06%  sample_benchmar  sample_benchmark_task_stack_pool  [.] my_task_action
+    1.61%     1.61%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::impl::task_impl::get_status
+    1.40%     1.40%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::this_task::get_task
+    1.29%     1.28%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp::this_coroutine::get_coroutine
+    0.98%     0.97%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::task&amp;lt;my_macro_coroutine, my_macro_task&amp;gt;::is_completed
+    0.83%     0.83%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::task&amp;lt;my_macro_coroutine, my_macro_task&amp;gt;::yield
+    0.77%     0.76%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::impl::task_impl::this_task
     0.72%     0.72%  sample_benchmar  sample_benchmark_task_stack_pool  [.] copp::detail::coroutine_context_base::is_finished
     0.51%     0.51%  sample_benchmar  sample_benchmark_task_stack_pool  [.] cotask::task&amp;lt;my_macro_coroutine, my_macro_task&amp;gt;::resume
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更细节的压力测试可以见： &lt;a href=&quot;https://travis-ci.org/owt5008137/libcopp&quot;&gt;Linux&amp;amp;maxOS&lt;/a&gt; 和 &lt;a href=&quot;https://ci.appveyor.com/project/owt5008137/libcopp&quot;&gt;Windows&lt;/a&gt; 里的运行结果，反正每次构建都会跑。&lt;/p&gt;

&lt;p&gt;顺便一提这次的优化也和&lt;a href=&quot;https://github.com/yyzybb537/libgo&quot;&gt;libgo&lt;/a&gt;学了一招，不止让CI跑单元测试了，也去跑压测。这样随时能看到性能数据。另外之前说改成Release后性能大幅提高，但是我想应该不会在乎这点性能吧，所以改回了RelWithDebInfo，毕竟万一出问题了，可以看core dump或者调试还是蛮重要的。&lt;/p&gt;

&lt;p&gt;不过我仍然保持一个观点，就是协程库只做好协程，所以并没有在里面集成一些系统调用的钩子，比如&lt;strong&gt;send&lt;/strong&gt;、&lt;strong&gt;write&lt;/strong&gt;等。这些应该通过附加组件的形式来做，并且又不难做，只是跨平台适配恶心点。所以我这里还是追求协程本身的功能和性能。&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

&lt;p&gt;C++1z后面可能C++会内置支持co_await之类的关键字了。我最近也在抽空看它的原理和文档。后面有时间我也会做一下这些的集成和支持的。不过这个还没那么快。&lt;/p&gt;

&lt;p&gt;还有就是前面提到的分支预测的优化，我也需要再找点资料。再评估一下，看看有没有必要搞进去。&lt;/p&gt;

&lt;p&gt;我思考了一下，虽然当时做了很多软件工程上的预留（比如允许共享action之类）。但是实际使用过程中，这些预留很多都没有必要，未来会考虑移除这些预留，并且和&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的call/cc一样直接分配在栈上，这样能进一步减少内存碎片，不过这个优化会导致结构变化和部分API向前不兼容，所以也需要再设计一下。大致的思路就是尽可能把这些数据保存在栈里，不需要额外分配，这样就减少了内存碎片，也同时减少malloc的负担。&lt;/p&gt;

&lt;p&gt;同时有必要进一步减少原子操作的频率，因为我这里测试的原子操作的每次写大约需要7ns，也就是大约是L1 cache的失效时间。现在有一些冗余可以进一步优化的。还有更多细节的地方可以优先使用右值引用来优化性能，这也能减少内部对原子操作的消耗。而且读写操作可以进一步优化同步屏障的类型，来减少cache miss的量。&lt;/p&gt;

&lt;p&gt;按照&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的call/cc的profile的结果，在协程对象创建上能够优化的量已经比较小了，但是在切换上还有比较大的优化空间，现在在有些情况下&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的切换效率接近&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/context/&quot;&gt;boost.context&lt;/a&gt;的call/cc，但是并不是很稳定有些情况还是会到200ns。当然因为要保证线程安全有些开销必不可少，所以的后续再深度分析一下。同时cotask的目前的创建开销和切换开销还比较大，还有比较可观的优化空间。不过这部分的对比因为和上面的一些优化点有关，所以我还是会优先解决上面提到的那些，再来看下效果。&lt;/p&gt;</content><author><name></name></author><category term="BOOST" /><category term="branch" /><category term="cache" /><category term="coroutine" /><category term="cpp" /><category term="g++" /><category term="gcc" /><category term="miss" /><category term="prediction" /><category term="分支预测" /><category term="协程" /><category term="多线程" /><category term="缓存" /><summary type="html"></summary></entry><entry><title type="html">libatbus的几个藏得很深的bug</title><link href="/article/work/2017-04-23/1411.html" rel="alternate" type="text/html" title="libatbus的几个藏得很深的bug" /><published>2017-04-24T07:48:54+08:00</published><updated>2017-04-24T07:48:54+08:00</updated><id>/article/work/2017-04-23/1411</id><content type="html" xml:base="/article/work/2017-04-23/1411.html">&lt;!-- toc --&gt;

&lt;p&gt;在写这篇文章前，我突然想到以前流行了一段时间的服务器面试题：当一个BUG只有几百万分之一的概率会出现，怎么办？这个问题在这个BUG里只是毛毛雨而已，因为这次的BUG的&lt;strong&gt;出现概率是夸张的三亿分之一&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我在好几年前自己开发了一个用于服务器进程间通信的框架，&lt;a href=&quot;https://github.com/atframework/libatbus&quot;&gt;libatbus&lt;/a&gt;，以前用在了客户端的模块隔离的通信心痛中。并且现在开始正式用于服务器。但是前两天看了一下服务器的日志，发现了比较奇怪的-202错误。&lt;/p&gt;

&lt;p&gt;这个问题本来是已知的，在当时通信系统设计并且做测试的时候就发现了这个问题，详见&lt;a href=&quot;https://www.owent.net/2014/1099.html&quot;&gt;关于BUS通信系统的一些思考（二）&lt;/a&gt;。后来经过几次设计细节的调整，具体的实现可这篇文章有一些变化，但是主要原理是一样的。&lt;/p&gt;

&lt;p&gt;因为在benchmark时BUG的发生概率在大约三亿分之一，并且在单进程多线程模式下没有发现过这个错误。并且后来在增加了自动重试之后很长时间都没出现过问题，所以当时认为可能是跨进程原子操作的时候可能内存屏障有些问题导致的。也没太在意，毕竟服务器本身也有一层超时保护，而且还得保持在高压力上才会发生,三亿分之一的发送错误实在微不足道。&lt;/p&gt;

&lt;p&gt;但是我们服务器程序开发阶段，压力不可能高，又出现这个问题，说明我之前的猜测是不对的（果然猜测是大忌啊）。虽然发生频率很低，但是通信服务是一个非常基础的东西，这就需要关注下保证更高的可靠性了。&lt;/p&gt;

&lt;h2 id=&quot;写工具分析问题&quot;&gt;写工具，分析问题&lt;/h2&gt;

&lt;p&gt;为了更深入地了解到底是什么情况，因为发生概率十分地低，所以很难抓到现场，第一步只能是写个小工具导出&lt;a href=&quot;https://github.com/atframework/libatbus&quot;&gt;libatbus&lt;/a&gt;共享内存通道的统计数据，然后发现有一些奇怪的计数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;summary:
channel node size: 128
channel node count: 123331
channel using memory size: 16777112
channel available node number: 123330

configure:
send timeout(ms): 4
protect memory size(Bytes): 123264
protect node number: 963
write retry times: 4

read&amp;amp;write:
first waiting time: 0
read index: 51896
write index: 51896
operation sequence: 1064070

stat:
bad block count: 22
bad node count: 3110
timeout block count: 18

read&amp;amp;write:
first waiting time: 0
read index: 51896
write index: 51896
operation sequence: 1064070
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在几个月的运行中，这种低负载的情况下，竟然出现了22次错误数据和18次timeout。这显然不太可能于是需要进一步地完善工具提供更多的信息。收集错误的数据。&lt;/p&gt;

&lt;h2 id=&quot;第一个bug-发生频率-三亿分之一&quot;&gt;第一个BUG: 发生频率-三亿分之一&lt;/h2&gt;

&lt;p&gt;第一个BUG，其实是review了一遍代码发现的。还是比较2B的BUG。&lt;/p&gt;

&lt;p&gt;原来的逻辑里有一段功能是为了防止某些发送端进程在写出数据时崩溃，为了在这种情况下接收端需要能够自动修复并跳过错误数据。但是接收端并不知道写出端是崩溃了还是正在写出，所以有一个遇到未完成写出的节点时的超时判定，在超时后认为出现错误而强制跳过。原来有BUG的代码如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 容错处理 -- 未写入完成
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF_WRITEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLOCKS_PER_SEC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 转换到毫秒
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 初次读取
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NO_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 写入超时
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_timeout_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_bad_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_bad_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_timeout_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 未到超时时间
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NO_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里面认为&lt;em&gt;first_failed_writing_time&lt;/em&gt;为0则是第一次出错，然后下一次recv的时候如果未超时则认为是写出端数据没写完而返回无数据，但是超时后返回错误并且跳过错误数据块。&lt;/p&gt;

&lt;p&gt;这里的问题就出在时间计算上，那里不应该是乘，而应该是除。在linux里，&lt;strong&gt;CLOCKS_PER_SEC / 1000&lt;/strong&gt;的值是1000，那么&lt;em&gt;cnow&lt;/em&gt;变成了1000倍的&lt;em&gt;clock()&lt;/em&gt;。然后还有个问题是超时时间不是&lt;em&gt;channel-&amp;gt;block_timeout_count&lt;/em&gt;，而且应该是，&lt;em&gt;channel-&amp;gt;conf.conf_send_timeout_ms&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;所以在这两个BUG的夹击下，只要是连续第二次进入判定超时阶段，十有八九会被判定为超时。之所以发生&lt;strong&gt;概率三亿分之一&lt;/strong&gt;，是以为其他情况下在第二次执行尝试读取数据时，写出端都把数据写完了，那么&lt;strong&gt;MF_WRITEN&lt;/strong&gt;就会被标记。所以这里必须是两次连续读期间写出端还没写完才行，所以发生频率才很低。&lt;/p&gt;

&lt;p&gt;所以修复完以后，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 容错处理 -- 未写入完成
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF_WRITEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLOCKS_PER_SEC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 转换到毫秒
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 初次读取
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NO_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 写入超时
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf_send_timeout_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_bad_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_bad_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_timeout_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_failed_writing_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 未到超时时间
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NO_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经过上面的修复，继续跑debug版本的benchmark，连续2小时都没再出现任何错误，但是切到&lt;strong&gt;RelWithDebInfo（-O2 -g -ggdb）&lt;/strong&gt;后大约平均十亿分之一的概率出现了错误记录。&lt;/p&gt;

&lt;h2 id=&quot;第二个bug-发生频率-十亿分之一到百亿分之一&quot;&gt;第二个BUG: 发生频率-十亿分之一到百亿分之一&lt;/h2&gt;

&lt;p&gt;这次已经没有这种很傻的BUG了，并且错误出现率进一步降低。这时候发现之前的错误信息转储不太能展示错误到底出现在哪个流程里。于是乎review完写出和接收端代码没有发现问题后我就给通道数据导出增加了更多的信息。这个信息后来证明很有价值。当时查出问题所在的日志我没保存，但是在我区分了各个状态的错误码后我发现了两个问题。&lt;/p&gt;

&lt;h3 id=&quot;第一个问题并没有出现超时校验码错误长度校验错误写重试和写错误的情况下单单出现了和节点错误计数十亿分之一&quot;&gt;第一个问题：并没有出现超时、校验码错误、长度校验错误、写重试和写错误的情况下，单单出现了和节点错误计数。（十亿分之一）&lt;/h3&gt;

&lt;p&gt;这个而只有在一个流程下没有其他计数只有节点错误计数。那就是如下位置:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;read_end_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// read_begin_cur是通过channel-&amp;gt;atomic_read_cur.load()获取的
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NO_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_get_node_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 容错处理 -- 不是起始节点
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF_START_NODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_begin_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_bad_node_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里本意是其他位置发现了错误，跳过起始节点，然后在主循环里计数并跳过所有的错误数据节点。但是莫名奇妙在没有检测到错误起始节点的情况下直接进了这个流程，就比较诡异了。&lt;/p&gt;

&lt;p&gt;后来我就再分析了发送端代码，结果发现了问题所在。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 查找可用数据节点阶段
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_read_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// std::atomic_thread_fence(std::memory_order_seq_cst);
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 要留下一个node做tail, 所以多减1
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_get_available_node_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_BUFF_LIMIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 新的尾部node游标
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;new_write_cur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// CAS
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 发现冲突原子操作失败则重试
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 数据缓冲区操作 - 初始化
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mem_block_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_get_block_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_block_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 数据缓冲区操作 - 要写入的节点
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;block_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_get_node_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;first_node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF_START_NODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;first_node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation_seq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opr_seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_write_cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_next_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_get_node_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_node_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;area_data_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 写数据node出现冲突
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 写超时会导致this_node_head还是之前版本的数据，并不会被清空。所以不再恢复 operation_seq
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// if (this_node_head-&amp;gt;operation_seq) {
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//     return EN_ATBUS_ERR_NODE_BAD_BLOCK_WSEQ_ID;
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// }
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;this_node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF_WRITEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;this_node_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation_seq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opr_seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;block_head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码先通过原子CAS操作获取到可用的内存块，然后对节点头设置标记位，并且在第一个节点设为&lt;strong&gt;MF_START_NODE&lt;/strong&gt;。问题就在这里，CAS操作是先进行的，然后第一个节点设为&lt;strong&gt;MF_START_NODE&lt;/strong&gt;在后。虽然这两个操作的距离很近，可能只涉及几十条指令。但是这段时间内如果进程被切出，然后读进程读到了CAS之后的写游标，又发现第一个节点不是&lt;strong&gt;MF_START_NODE&lt;/strong&gt;的时候，就被判为错误节点了，于是乎才丢失了数据。这个问题处理起来比较麻烦，因为不能破坏对真正错误数据的容错处理，还要能正确处理这种情况。&lt;/p&gt;

&lt;p&gt;最终我分析了一下流程，在读取端获取了新的写游标位置后，可能写出端处于移动了atomic_write_cur，但是还没有写出&lt;strong&gt;MF_START_NODE&lt;/strong&gt;的情况。所以情况列举如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;**MF_START_NODE&lt;/td&gt;
          &lt;td&gt;MF_WRITEN**: 数据块已写完&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MF_WRITEN&lt;/strong&gt;: 节点容错&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MF_START_NODE&lt;/strong&gt;: 是起始节点但是数据未写完（也可能是发送端在写出过程中崩溃）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;空&lt;/strong&gt;: 移动游标后尚未设置&lt;strong&gt;MF_START_NODE&lt;/strong&gt;，这个出现概率非常低，但是也会出现。（也可能是发送端在写出过程中崩溃）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于&lt;strong&gt;MF_START_NODE&lt;/strong&gt;和&lt;strong&gt;空&lt;/strong&gt;都是无法判定是没写完还是写出端崩溃的，所以都要走超时检测逻辑。&lt;/p&gt;

&lt;p&gt;但是如果被判定超时并且写出端只写出了部分节点的的&lt;strong&gt;MF_WRITEN&lt;/strong&gt;这时候剩下的节点的flag都会是空。&lt;/p&gt;

&lt;p&gt;如果这些都通过超时机制判定，则最多可能等待&lt;strong&gt;消息长度*超时判定时长/节点长度&lt;/strong&gt;，&lt;em&gt;默认设置是最少2秒钟&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;所以这里需要特别处理下，当进入超时流程后，所有非&lt;strong&gt;MF_START_NODE&lt;/strong&gt;并且&lt;em&gt;operation_seq&lt;/em&gt;相等的节点也应该视为错误。&lt;/p&gt;

&lt;p&gt;注意上面这个流程只能在超时流程中进行，因为其他错误流程可能第一个数据块错误，但是紧接着的第二个数据块处于正在写出的状态而没有设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MF_START_NODE&lt;/strong&gt;和&lt;em&gt;operation_seq&lt;/em&gt;。我们的&lt;em&gt;operation_seq&lt;/em&gt;取值范围是uint32，所以max(uint32)&lt;em&gt;节点长度（默认是500GB）以内的通道里&lt;/em&gt;operation_seq*不会重复&lt;/p&gt;

&lt;p&gt;我们的数据通道不可能使用这么大的内存，所以加上&lt;em&gt;operation_seq&lt;/em&gt;后能尽可能地消除空数据快的超时影响。&lt;/p&gt;

&lt;h3 id=&quot;第二个问题更诡异的数据被复写百亿分之一&quot;&gt;第二个问题：更诡异的数据被复写（百亿分之一）&lt;/h3&gt;

&lt;p&gt;重点日志如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shm_recv error, ret code: -202. start: 101398, end: 101403
Summary:
    channel node size: 128
    channel node count: 123331
    channel using memory size: 16777112
    channel available node number: 12578
Configure:
    send timeout(ms): 4
    protect memory size(Bytes): 16384
    protect node number: 128
    write retry times: 4
IO:
    first waiting time: 0
    read index: 101403
    write index: 88696
    operation sequence: 4023560795
Statistics:
    write - check sequence failed: 0
    write - retry times: 0
    read - bad node: 16
    read - bad block: 0
    read - write timeout: 0
    read - check block size failed: 0
    read - check node count failed: 1
    read - check hash failed: 0
Debug:
    last action - channel: 0x7f9291997000
    last action - begin node index: 101398
    last action - end node index: 101403
......
Node index:     101398 =&amp;gt; seq=4023547849, is start node=No, is written=No, data(Hex): 3807000000000000fdeb7cfc0000000000670100b0b0b0b0
Node index:     101399 =&amp;gt; seq=4023547849, is start node=No, is written=No, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101400 =&amp;gt; seq=4023547849, is start node=No, is written=No, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101401 =&amp;gt; seq=4023547849, is start node=No, is written=No, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101402 =&amp;gt; seq=4023547849, is start node=No, is written=No, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101403 =&amp;gt; seq=4023533496, is start node=Yes, Data Length=616, Hash=872284744, is written=Yes, data(Hex): 68020000000000004802fe3300000000fe66010033333333
Node index:     101404 =&amp;gt; seq=4023533496, is start node=No, is written=Yes, data(Hex): 333333333333333333333333333333333333333333333333
Node index:     101405 =&amp;gt; seq=4023533496, is start node=No, is written=Yes, data(Hex): 333333333333333333333333333333333333333333333333
Node index:     101406 =&amp;gt; seq=4023533496, is start node=No, is written=Yes, data(Hex): 333333333333333333333333333333333333333333333333
Node index:     101407 =&amp;gt; seq=4023533496, is start node=No, is written=Yes, data(Hex): 333333333333333333333333333333333333333333333333
Node index:     101408 =&amp;gt; seq=4023547849, is start node=No, is written=Yes, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101409 =&amp;gt; seq=4023547849, is start node=No, is written=Yes, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101410 =&amp;gt; seq=4023547849, is start node=No, is written=Yes, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101411 =&amp;gt; seq=4023547849, is start node=No, is written=Yes, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101412 =&amp;gt; seq=4023547849, is start node=No, is written=Yes, data(Hex): b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0
Node index:     101413 =&amp;gt; seq=4023547850, is start node=Yes, Data Length=1864, Hash=938159398, is written=Yes, data(Hex): 4807000000000000262deb3700000000ff66010027272727
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;节点101398已被跳过，所以&lt;strong&gt;MF_START_NODE&lt;/strong&gt;标记被清理了，但是在出错时这里是其实节点。这个数据环境是三进程写，一进程读，通道长度16MB，超时判定4ms。&lt;/p&gt;

&lt;p&gt;出错的结果是有一块数据被复写而丢失了。&lt;/p&gt;

&lt;p&gt;错误数据在 &lt;strong&gt;Node index:     101398&lt;/strong&gt; 处。中间被插入了&lt;strong&gt;Node index:     101403&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;插入偏移量等于&lt;strong&gt;Node index:     101403&lt;/strong&gt;的长度。怀疑是&lt;em&gt;compare_exchange_weak&lt;/em&gt;在成功后内存未接受内存屏障进cache，并且返回失败，在下一次操作直接成功。&lt;/p&gt;

&lt;p&gt;另外发现&lt;strong&gt;Node index:     101403&lt;/strong&gt;的操作序号远低于&lt;strong&gt;Node index:     101398&lt;/strong&gt;。开始分析认为可能是进程&lt;strong&gt;fe660100&lt;/strong&gt;被切出，超时时间后才切回。导致前一次写数据覆写了后面的。但是这种情况应该先会被判定为缓冲区不足，而不是直接覆写。如果是接收端进入了超时检测分支，那么会有超时计数。但是包括后面几小时后的数据，超时计数都一直是0。所以排除了这种情况。&lt;/p&gt;

&lt;p&gt;由于 &lt;a href=&quot;http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange&quot;&gt;http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange&lt;/a&gt; 里建议除非涉及数据表示多重含义或者附带对齐或数据切割，否则建议使用&lt;em&gt;compare_exchange_strong&lt;/em&gt;。所以改成了&lt;em&gt;compare_exchange_strong&lt;/em&gt;。可能是平台里原子操作的缓存逻辑问题所致。这篇文档里也说了&lt;em&gt;compare_exchange_weak&lt;/em&gt;的情况下某些成功的行为会类似失败所以保险起见换成了&lt;em&gt;compare_exchange_strong&lt;/em&gt;。而且后来压力测试也没发现性能有下降，所以就保持这样了。&lt;/p&gt;

&lt;h2 id=&quot;顺带一点点小优化&quot;&gt;顺带一点点小优化&lt;/h2&gt;

&lt;p&gt;这次BUG也查了挺久，加上移入了一些其他依赖库的一些小细节功能，所以随手加上了一些小优化。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cmake的环境配置不再使用加编译宏的形式，而是configure(detail/libatbus_config.h.in)文件。这样如果移植给其他模块使用可以直接用生成好的头文件，保持配置一致。&lt;/li&gt;
  &lt;li&gt;很多地方都是在冲突时才有分支流程，这些地方加了一些likely和&lt;em&gt;unlikely&lt;/em&gt;,已辅助编译器进行编译优化。&lt;/li&gt;
  &lt;li&gt;完善导出共享内存通道数据的小工具，原来输出的可读性稍微差一点。&lt;/li&gt;
  &lt;li&gt;因为是内存操作，增加了一些&lt;em&gt;volatile&lt;/em&gt;。但是测试的时候未见性能下降，所以为保证正确，就留着了。这样能保证更快速的内存同步。&lt;/li&gt;
  &lt;li&gt;压力测试工具实现了更严格的数据校验，保证数据完全可预测然后精确校验数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;新的稳定性测试&quot;&gt;新的稳定性测试&lt;/h2&gt;

&lt;p&gt;在上面的修复完成后我又进行了一整天的benchmark，环境仍然是三进程写，一进程读，通道长度16MB，超时判定4ms。最后的log如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ RUNNING  ] NO.1450 m
[ RUNNING  ] recv(93055489089 times, 88395 GB) recv err 0 times, data valid failed 0 times 

Summary:
    channel node size: 128
    channel node count: 123331
    channel using memory size: 16777112
    channel available node number: 1775

Configure:
    send timeout(ms): 4
    protect memory size(Bytes): 16384 
    protect node number: 128
    write retry times: 4

IO:
    first waiting time: 0
    read index: 117979
    write index: 116075
    operation sequence: 2877148690

Statistics:
    write - check sequence failed: 0
    write - retry times: 0
    read - bad node: 0
    read - bad block: 0
    read - write timeout: 0
    read - check block size failed: 0
    read - check node count failed: 0
    read - check hash failed: 0

Debug:
    last action - channel: 0x7f5688d7b000
    last action - begin node index: 118300
    last action - end node index: 118301
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的性能指标低于文档里说示的结果，是因为这并不是单独对吞吐量和QPS的压力测试，发包的数据量比较大，范围是8B-2KB平均是1KB，所以QPS只有一百万多一点点，吞吐量也只是1GB/s多一点。但是实际性能并没有下降，因为改完之前这个数据包范围的数据也差不多是这样。当然以后有空还是可以重跑下压力测试。&lt;/p&gt;

&lt;p&gt;最重要的是，可以看到一整天的满负载执行后，并没有出现一次错误。我们这次的BUG修复就算圆满达成了。&lt;/p&gt;</content><author><name></name></author><category term="bus" /><category term="c++0x/11" /><category term="c++11" /><category term="cpp" /><category term="g++" /><category term="gcc" /><category term="linux" /><category term="thread" /><category term="windows" /><category term="内存实现" /><category term="多线程" /><category term="无锁队列" /><category term="消息队列" /><category term="进程间通信" /><summary type="html"></summary></entry><entry><title type="html">用cmake交叉编译到iOS和Android</title><link href="/article/work/2017-04-16/1405.html" rel="alternate" type="text/html" title="用cmake交叉编译到iOS和Android" /><published>2017-04-16T11:37:17+08:00</published><updated>2017-04-16T11:37:17+08:00</updated><id>/article/work/2017-04-16/1405</id><content type="html" xml:base="/article/work/2017-04-16/1405.html">&lt;!-- toc --&gt;

&lt;p&gt;最近看了下最新版本的cmake的文档，很惊喜地发现他已经支持直接设置Android和OSX的一些变量了，然后有瞄了一眼NDK，发现里面现在也停工官方的cmake支持。&lt;/p&gt;

&lt;p&gt;索性干脆试试用cmake做对android和iOS平台的一些库的交叉编译，这样用cmake的环境监测系统就会比原来写Makefile+脚本要简单多了。&lt;/p&gt;

&lt;h2 id=&quot;编译ios工程&quot;&gt;编译iOS工程&lt;/h2&gt;

&lt;p&gt;iOS 只要设置CMAKE_OSX_SYSROOT，CMAKE_SYSROOT和CMAKE_OSX_ARCHITECTURES就可以了，其他都是自动的。唯一要注意的是，iOS不允许使用动态库，所以只能用静态库的话要加-fPIC参数。比如&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-DCMAKE_C_FLAGS&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fPIC&quot;&lt;/span&gt; -DCMAKE_CXX_FLAGS&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fPIC&quot;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就完事了。&lt;/p&gt;

&lt;p&gt;主要还是要检测一下上面提到的那几个参数要设置成什么。而这些，都可以通过&lt;em&gt;xcode-select -print-path&lt;/em&gt;来获取。默认的SDK版本则可以通过&lt;em&gt;xcrun -sdk iphoneos –show-sdk-version&lt;/em&gt;获取。&lt;br /&gt;
当然前提都是安装了Commandline工具集。然后编译几个不同架构的.a，最后用&lt;em&gt;lipo&lt;/em&gt;打包到一起就行了。&lt;/p&gt;

&lt;p&gt;比如，我的&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;atsf4g-co&lt;/a&gt;里可以用&lt;a href=&quot;https://tls.mbed.org/&quot;&gt;mbedtls&lt;/a&gt;来加解密，但是&lt;a href=&quot;https://tls.mbed.org/&quot;&gt;mbedtls&lt;/a&gt;只有cmake文件，并没有编译iOS版本的文档。就可以通过上面的命令编译打包静态库。脚本地址： https://github.com/owent-utils/bash-shell/blob/master/Build/mbedtls/build_mbedtls_ios.sh&lt;/p&gt;

&lt;p&gt;再然后，因为我们的项目有用到&lt;a href=&quot;https://github.com/owent-contrib/pbc&quot;&gt;pbc&lt;/a&gt;所以我也给&lt;a href=&quot;https://github.com/owent-contrib/pbc&quot;&gt;pbc&lt;/a&gt;和它的lua-binding写了cmake的适配和打包脚本。脚本地址： https://github.com/owent-contrib/pbc/blob/master/build_ios.sh&lt;/p&gt;

&lt;h2 id=&quot;编译android工程&quot;&gt;编译Android工程&lt;/h2&gt;
&lt;p&gt;编译Android工程其实要麻烦点，首先支持平台多，并没有一种官方的方式自动查找NDK地址，所以得指定NDK地址。索性是现在版本的NDK里自带了对cmake适配的文件。在NDK目录/build/cmake下，有个android.toolchain.cmake的文件。只要cmake的时候把cmake的工具链检测文件改成这个就行了。也就是命令参数加一个&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-DCMAKE_TOOLCHAIN_FILE&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK_ROOT&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/build/cmake/android.toolchain.cmake&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Android下设置PIC不需要直接在CMAKE_C_FLAGS和CMAKE_CXX_FLAGS里加-fPIC选项了。NDK里的android.toolchain.cmake文件提供了ANDROID_PIE选项，直接设置成YES就好了。&lt;/p&gt;

&lt;p&gt;另外Android这个工具链还允许我们选择用哪个STL库（ANDROID_STL选项）、设置NDK目录（ANDROID_NDK选项）和设置使用gcc还是clang（ANDROID_TOOLCHAIN选项）。当然这只是主要最可能用到的几个，其他还有一些得看android.toolchain.cmake文件了，里面有写。&lt;/p&gt;

&lt;p&gt;不过使用Android这个文件指定工具链的时候有一个问题，android.toolchain.cmake指定了只从sysroot来获取include目录和库目录，也就是说很多module里可以指定库的搜索目录在android ndk下都是无效的。具体来说就是&lt;em&gt;find_library&lt;/em&gt;和&lt;em&gt;find_path&lt;/em&gt;之类的函数。所以有一些依赖库检测的脚本需要在这种情况下跳过检查，直接用。&lt;/p&gt;

&lt;p&gt;所以，还是和上面iOS的编译一样，我写了个给&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;atsf4g-co&lt;/a&gt;使用的&lt;a href=&quot;https://tls.mbed.org/&quot;&gt;mbedtls&lt;/a&gt;的打包脚本，地址： https://github.com/owent-utils/bash-shell/blob/master/Build/mbedtls/build_mbedtls_android.sh&lt;/p&gt;

&lt;p&gt;同时，也对&lt;a href=&quot;https://github.com/owent-contrib/pbc&quot;&gt;pbc&lt;/a&gt;的cmake适配写了打包android动态库的脚本： https://github.com/owent-contrib/pbc/blob/master/build_android.sh&lt;/p&gt;

&lt;p&gt;前面提到的android工具链只能从sysroot查询包含目录、执行目录和库目录。但是实际上编译参数里是加了那些目录的，所以需要对库检测做一些兼容。刚好&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;atsf4g-co&lt;/a&gt;的网关层需要给客户端编译的Android和iOS代码，所以写了导出库的依赖检测适配 https://github.com/atframework/atsf4g-co/blob/master/atframework/export/atgw_inner_v1_c/CMakeLists.export.txt#43&lt;/p&gt;</content><author><name></name></author><category term="android" /><category term="cmake" /><category term="ios" /><category term="ndk" /><summary type="html"></summary></entry><entry><title type="html">atapp的c binding和c#适配</title><link href="/article/work/2017-02-15/1367.html" rel="alternate" type="text/html" title="atapp的c binding和c#适配" /><published>2017-02-16T07:27:51+08:00</published><updated>2017-02-16T07:27:51+08:00</updated><id>/article/work/2017-02-15/1367</id><content type="html" xml:base="/article/work/2017-02-15/1367.html">&lt;!-- toc --&gt;

&lt;p&gt;这两天在做服务器框架的C的接口导出和C#的接入。之所以要做这么个东西是因为之前的服务器框架（&lt;a href=&quot;https://github.com/atframework/atsf4g-co&quot;&gt;atsf4g-co&lt;/a&gt;）已经完成了通信层面和基本设计模式的细节部分，而且基本算是最大化性能了吧。但是现在的项目的战斗引擎是从以前Unity游戏上抽象而来的，全部由C#编写。再加上最近再考虑接入实时战斗，这样就不能像之前一样用一个简单的通信方式了，必须使用一个高效并且实时性更高通信机制。需要能够处理好比较高的集中式的组播和容灾的通信方式。于是就有了把之前的C++的框架抽离出API来驱动逻辑的想法。这样也比较容易地兼顾开发成本和性能之间地权衡。&lt;/p&gt;

&lt;h2 id=&quot;c-binding&quot;&gt;C Binding&lt;/h2&gt;

&lt;p&gt;那么抽离出框架地目的是抽象出应用底层，这个刚好是&lt;a href=&quot;https://github.com/atframework/libatapp&quot;&gt;atapp&lt;/a&gt;做的事，而且&lt;a href=&quot;https://github.com/atframework/libatapp&quot;&gt;atapp&lt;/a&gt;的层面对外暴露的接口数量也比较少，使用比较简单，所以索性就直接对它下手了。&lt;/p&gt;

&lt;p&gt;让后第一步是把&lt;a href=&quot;https://github.com/atframework/libatapp&quot;&gt;atapp&lt;/a&gt;需要使用的基本接口抽离出纯C的导出API。之所以要导出成纯C是因为，不同系统环境和编译器环境在C++层符号规则、入栈出栈顺序、内存布局、对其规则等等都不一样。这种情况要做跨平台就很是困难，然而这些在纯C的ISO里都是有明确规范的。所以最简单的方式就是导出到纯C，然后其他语言导入接口。这里的其他语言目前就只有C#，但是纯C接口的话如果想导出到lua或者其他语言的接口也不困难。&lt;/p&gt;

&lt;p&gt;这里导出的时候有一点点小细节，那就是在Linux上的c api是默认导出的，但是在Windows里是默认不导出的，然后再加上不同编译器的导出用法不一样，所以第一步当然是统一导出标记。最终就是下面这一段&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#if !defined(ATFRAME_SYMBOL_EXPORT) &amp;amp;&amp;amp; defined(_MSC_VER)
#define ATFRAME_SYMBOL_EXPORT __declspec(dllexport)
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#elif !defined(ATFRAME_SYMBOL_EXPORT) &amp;amp;&amp;amp; defined(__GNUC__)
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifndef __cdecl
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// see https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html
// Intel x86 architecture specific calling conventions
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef _M_IX86
#define __cdecl __attribute__((__cdecl__))
#else
#define __cdecl
#endif
#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if defined(__clang__)
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if !defined(_WIN32) &amp;amp;&amp;amp; !defined(__WIN32__) &amp;amp;&amp;amp; !defined(WIN32)
#define ATFRAME_SYMBOL_EXPORT __attribute__((__visibility__(&quot;default&quot;)))
#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if __GNUC__ &amp;gt;= 4
#if (defined(_WIN32) || defined(__WIN32__) || defined(WIN32)) &amp;amp;&amp;amp; !defined(__CYGWIN__)
#define ATFRAME_SYMBOL_EXPORT __attribute__((__dllexport__))
#else
#define ATFRAME_SYMBOL_EXPORT __attribute__((__visibility__(&quot;default&quot;)))
#endif
#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifndef ATFRAME_SYMBOL_EXPORT
#define ATFRAME_SYMBOL_EXPORT
#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到即便同一个编译器，在不同系统上都还不一样。上面这些基本上兼顾了主流的平台和编译器了。然后如果要导出c函数就是类似这样：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libatapp_c_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ATFRAME_SYMBOL_EXPORT&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__cdecl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libatapp_c_run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libatapp_c_context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ATFRAME_SYMBOL_EXPORT&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__cdecl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libatapp_c_reload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libatapp_c_context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有两个小细节，一个是那个&lt;strong&gt;union&lt;/strong&gt;，这是为了内部做类型转换方便，因为要考虑到导出到其他语言的接口，所以这里的内存长度必须是一个指针长度。然后用union做数据类型转换而不是直接强转是为了消除有些编译器下的&lt;em&gt;warning&lt;/em&gt;；第二就是所有的类型都使用定长的，即便在64位系统下，大多数的容器的size类型都是&lt;em&gt;size_t&lt;/em&gt;或&lt;em&gt;size_type&lt;/em&gt;并且等同于&lt;em&gt;uint64_t&lt;/em&gt;，那我们这里也要用&lt;em&gt;uint64_t&lt;/em&gt;，这也是为了跨环境的时候接口的布局是一致的。&lt;/p&gt;

&lt;p&gt;再后面都全部是一些操作的封装了。我们大致封装的接口有这几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atapp的创建和删除&lt;/li&gt;
  &lt;li&gt;atapp的信息和状态函数&lt;/li&gt;
  &lt;li&gt;atapp获取框架层配置文件（因为我们这里用的是结构化的ini，那么为了统一配置，也可以提供基本的读取工具给逻辑）&lt;/li&gt;
  &lt;li&gt;atapp的基本时间类接口（目前就获取当前Unix时间戳）&lt;/li&gt;
  &lt;li&gt;框架log接口（以便逻辑log导入到框架规则）&lt;/li&gt;
  &lt;li&gt;通信接口（目前版本是发送数据和发送命令）&lt;/li&gt;
  &lt;li&gt;控制接口（&lt;em&gt;listen&lt;/em&gt;和&lt;em&gt;connect&lt;/em&gt;等）&lt;/li&gt;
  &lt;li&gt;各类回调函数接口（连接/断开其他服务器节点、接收到消息、发送失败等）&lt;/li&gt;
  &lt;li&gt;atapp的模块接口（模块用于触发reload、定时器等操作）&lt;/li&gt;
  &lt;li&gt;atapp的扩展功能（目前是绑定启动参数和自定义命令的回调）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前每种类型都是只封装了会用到的一些接口，后面有特殊需求了会再添加绑定的API。&lt;/p&gt;

&lt;h2 id=&quot;c适配&quot;&gt;C#适配&lt;/h2&gt;

&lt;p&gt;纯C的接口封装完以后就可以导入到.net了。由于.net我并不是特别熟，所以还是碰到了一些问题的。&lt;/p&gt;

&lt;h3 id=&quot;回调函数的生命周期问题&quot;&gt;回调函数的生命周期问题&lt;/h3&gt;

&lt;p&gt;碰到的第一个就是回调函数生命周期的问题，因为在C#层我会封装一个高级的delegate，然而传入到C API的都是C函数。C#提供了一个方法就是用&lt;strong&gt;Marshal.GetFunctionPointerForDelegate&lt;/strong&gt;把C#的delegate转换为C函数指针。比如:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnDisconnectedFunction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnDisconnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_on_disconnected_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_native_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;native object invalid&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_on_disconnected_fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_on_disconnected_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Marshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetFunctionPointerForDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_on_disconnected_holder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;libatapp_c_on_disconnected_fn_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libatapp_c_on_disconnected_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;libatapp_c_set_on_disconnected_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_native_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里就有两个对象，一个是value，保存到了&lt;em&gt;_on_disconnected_fn&lt;/em&gt;，另一个是libatapp_c_on_disconnected_fn(即便他是静态函数也一样)保存到了&lt;em&gt;_on_disconnected_holder&lt;/em&gt;。为啥有两个呢？回调函数不就一个嘛？这就是坑之一，我必须保存这个&lt;em&gt;libatapp_c_on_disconnected_fn&lt;/em&gt;，否者这个函数会被.net GC回收掉，然后C API回调的时候&lt;strong&gt;可能&lt;/strong&gt;会崩溃。之所以是&lt;strong&gt;可能&lt;/strong&gt;是因为你不知道.net会什么时候释放掉它。&lt;/p&gt;

&lt;p&gt;这还引出一个问题就是这类的回调函数的数据组很多，也可能是我不太会用C#的泛型，导致这些API都是手写的。感觉写的时候很危险很容易出错啊。我最多就用到了这样:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EventCallbackRefGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TC&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventFunction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_on_init_call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ATBUS_ERROR_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_BAD_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ATBUS_ERROR_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_ATBUS_ERR_NOT_INITED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventCallbackRefGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libatapp_c_module_on_init_fn_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventCallbackRefGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libatapp_c_module_on_init_fn_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventFunction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OnInit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_native_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidOperationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Module released&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Marshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetFunctionPointerForDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;libatapp_c_module_on_init_fn_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_on_init_call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;libatapp_c_module_set_on_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_native_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NativeApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每个回调组有这么多代码，如果是C++的话有很方便的方法家编译器约束和减少这种代码量。因为C++的模板参数可以不止是类型，还可以是值。并且functor可以封入很多额外信息。&lt;/p&gt;

&lt;h3 id=&quot;c的string类型和c的charconst-char&quot;&gt;C#的string类型和C的char*/const char*&lt;/h3&gt;

&lt;p&gt;忘了哪里看到的C#的文档说string到const char*之类是会按ANSI编码自动转换的。但是我实测是我如果从C#层传到C层是没问题，但是反过来会发生访问内存出错。估计是传入C的是.net自己把string的数据指针直接传给C了，但是反过来它并没有按照ANSI的0来判定字符串结尾。所以后面的传出的字符串数据都得这样。&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[DllImport(Message.LIBNAME, CallingConvention = CallingConvention.Cdecl)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;libatapp_c_get_app_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;versz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppVersion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_native_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufsz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;libatapp_c_get_app_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_native_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufsz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Marshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PtrToStringAnsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;verbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bufsz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再就是数组的接口比较独特，要加特殊的标记，然后传入的数据不用加out或者ref，仍然是可写的，比如这样:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[DllImport(Message.LIBNAME, CallingConvention = CallingConvention.Cdecl)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;libatapp_c_get_configure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                                                     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MarshalAs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnmanagedType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
&lt;span class=&quot;na&quot;&gt;[MarshalAs(UnmanagedType.LPArray)]&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr_sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实也可以理解，本来C#里传这类东西过去的都是引用，只是到C层丢失了长度参数而已。&lt;/p&gt;

&lt;h3 id=&quot;非托管数据到托管数据的开销&quot;&gt;非托管数据到托管数据的开销&lt;/h3&gt;

&lt;p&gt;有一个东东不能不提。那就是数据是从C过来的，如果暴露原始指针给上层并且有上层来做&lt;strong&gt;Marshal&lt;/strong&gt;操作则使用成本有点高了。所以还是会转成托管数据给上层用。那么这时候就会有一次数据拷贝。这也会导致比直接使用C++的&lt;a href=&quot;https://github.com/atframework/libatapp&quot;&gt;atapp&lt;/a&gt;多一层性能消耗。比如所有的Message的二进制传递。不过一般情况下这个占比不会特别大，只是这个开销确实存在。&lt;/p&gt;

&lt;h3 id=&quot;net的支持十分的诡异&quot;&gt;.net的支持十分的诡异&lt;/h3&gt;

&lt;p&gt;最后一个问题是既然写了这个接入，我就希望能够做好跨平台。现在有了.net core、mono和.net framework。mono都是按.net framework的API做兼容的问题倒不大，只是一些特性不能用而已。但是.net core和.net framework差异就不较大了。现在的适配是按照.net standard的标准进行的，理论上是能同时跨平台兼容.net framework和.net core。但是微软有个文档说明.net standard的支持情况,https://docs.microsoft.com/zh-cn/dotnet/articles/standard/library 。&lt;/p&gt;

&lt;p&gt;简单来说就是这样:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;平台名称&lt;/th&gt;
      &lt;th&gt;Alias&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;.NET Standard&lt;/td&gt;
      &lt;td&gt;netstandard&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;1.1&lt;/td&gt;
      &lt;td&gt;1.2&lt;/td&gt;
      &lt;td&gt;1.3&lt;/td&gt;
      &lt;td&gt;1.4&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;1.6&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.NET 核心&lt;/td&gt;
      &lt;td&gt;netcoreapp&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;vNext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.NET Framework&lt;/td&gt;
      &lt;td&gt;net&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;4.5&lt;/td&gt;
      &lt;td&gt;4.5.1&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;4.6.1&lt;/td&gt;
      &lt;td&gt;4.6.2&lt;/td&gt;
      &lt;td&gt;vNext&lt;/td&gt;
      &lt;td&gt;4.6.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mono/Xamarin 平台&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;vNext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;通用 Windows 平台&lt;/td&gt;
      &lt;td&gt;uap&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;10.0&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;vNext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Windows&lt;/td&gt;
      &lt;td&gt;win&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;8.0&lt;/td&gt;
      &lt;td&gt;8.1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Windows Phone&lt;/td&gt;
      &lt;td&gt;wpa&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;→&lt;/td&gt;
      &lt;td&gt;8.1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Windows Phone Silverlight&lt;/td&gt;
      &lt;td&gt;wp&lt;/td&gt;
      &lt;td&gt;8.0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看到这里面就没有交叉的部分，我也是醉了。目前我制定的是 .net standard 1.3。因为2.0版本还没有Release的SDK，1.6版本.net framework不支持。而即便是1.3，也需要.net framework 4.6以上。所以这次的适配完成和功能测试，我都是只拿了Windows上的.net framework测试的。上面列举的基本功能的都测试完成了，但是并没有试Mono或者.net core上是否可以。理论上应该可以吧，当然后续免不了接口会有些调整。&lt;/p&gt;

&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;现在基本功能和流程算是通了吧。这也是一个里程碑的阶段，后续肯定还需要调整，但是方案基本就这样没跑了。并且如果以后兴起新的技术和解决方案，&lt;a href=&quot;https://github.com/atframework/libatapp&quot;&gt;atapp&lt;/a&gt;也可以很容易的适配过去。说不定哪天咱用go呢。&lt;/p&gt;

&lt;p&gt;最后的最后，还是本次适配最终成果的仓库及测试代码吧，都在这里了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;C Binding:&lt;/strong&gt; https://github.com/atframework/libatapp/blob/master/binding/c&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C#适配:&lt;/strong&gt; https://github.com/atframework/Atapp-CSharp&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term=".NET" /><category term="csharp" /><category term="server" /><category term="服务器" /><category term="消息队列" /><category term="进程间通信" /><summary type="html"></summary></entry><entry><title type="html">对象路由系统设计</title><link href="/article/work/2017-02-04/1342.html" rel="alternate" type="text/html" title="对象路由系统设计" /><published>2017-02-05T03:01:45+08:00</published><updated>2017-02-05T03:01:45+08:00</updated><id>/article/work/2017-02-04/1342</id><content type="html" xml:base="/article/work/2017-02-04/1342.html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;起源&quot;&gt;起源&lt;/h2&gt;

&lt;p&gt;现在的手游也开始越来越复杂，以前少量交互线上保存的服务器架构越来越不能满足现在越来越偏向PC端MMORPG的需求。比如现在手游也引入了地图服务、公会服务等等。特别是地图服务需要能够动态切换服务节点、并且由于广播量巨大，导致我们得用更多级的缓存和更复杂的负载均衡。这些缓存和负载均衡都会涉及缓存失效、同步、更新、发现延迟等问题，所以越来越需要一个路由系统来解决这些问题。&lt;/p&gt;

&lt;p&gt;那么为什么不用kafka之类成熟的消息分发系统呢？其实是我没找到成熟的特别适合游戏的路由系统。比如kafka虽然很强大，但是不适合太多topic，但是游戏中的路由要以玩家或工会或某个逻辑实体为单位，会导致有海量的topic。&lt;/p&gt;

&lt;p&gt;一般MMO都会设计一套合适的消息路由来完成这件事，但是这对手游的成本还是有点偏高。因为这会多一组服务器会专门维护不同类型的路由消息，并且不同服务器要分别有订阅、回发分类功能，还要做容灾，比较复杂。所以时间工期的原因，我这里就设计了一套对象路由系统。这样很多想类似的功能可以复用同一份代码实现，并且和项目中的对象类型关系比较紧密，试用上也方便一些。&lt;/p&gt;

&lt;p&gt;当然如果说时间和人力足够，还是专门的消息路由系统比较好。毕竟消息路由系统更严谨、接口一致、通用性也更高。并且由于隔离度更高，所以对使用者来说，坑会少非常多，并且和本身业务逻辑的互相影响会笑很多。简单得说，消息路由系统其实比我这个对象路由在接口隔离、依赖反转、单一职责方面会做得更好。&lt;/p&gt;

&lt;h2 id=&quot;对象路由的实现&quot;&gt;对象路由的实现&lt;/h2&gt;

&lt;h3 id=&quot;基础定义&quot;&gt;基础定义&lt;/h3&gt;

&lt;p&gt;首先要有两个名词定义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：指的是路由系统中的数据对象为缓存，这时候并不是时时数据，但会定期更新。缓存数据是只读的（除了一些特殊的同步流程）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实体&lt;/strong&gt;：指的是路由系统中的数据对象标记当前进程为实时数据的操作者，这时候数据可写，而且一个实体数据同时只能在一个进程上。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;逻辑对象&lt;/strong&gt;: 每个路由系统中的数据类型都会对应一个立即对象，包含着这种数据的逻辑索引、逻辑功能和对数据的重组织。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;路由ID:&lt;/strong&gt; 路由实体对象所在的进程ID&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于协程的存在，大幅简化了对象路由系统巨复杂的数据透传问题和RPC组合的问题。因为对外暴露的借口是很简单的，就是查询和移除缓存或者实体。但是实际执行过程中会根据当前是否有缓存，是否是实体，缓存是否过期等等执行不同的拉取、初始化流程。这其中还会有一些错误容忍，并重试（当然如果不存在就不需要重试）的过程。这些流程有很多步骤是异步的，再加上一些等待数据的排队功能，非常复杂。协程最大化简化了这些恶心的流程的数据透传和回调，使得每个功能块都只关注自己的那一部分，不用关注多个RPC功能组合带来的复杂度。&lt;/p&gt;

&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;首先要定义路由对象和路由对象模板&lt;/strong&gt;，有一些共通的操作是给予类型的，所以要用模板。路由基类定义必须要实现的接口和路由信息的维护功能和一些时间和状态管理即可。具体接口下面有写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后要定义管理器和管理器模板&lt;/strong&gt;，管理器要保存数据和索引，所以必然是基于类型的。然后有一些通用操作也在这里面完成，比如路由转移的操作、缓存升级实体的时候的数据重拉取和flag标记、降级的时候的数据保存、统一的索引管理等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再就是定义管理器集合管理器&lt;/strong&gt;，统一定时器的管理，主要是定时降级、淘汰和触发数据保存。这样统一到一个单例中。这样不用每个manager里都实现一遍。另外还可以把原本游戏服务器中单独处理的缓存和超时管理直接利用这个管理器的定时系统保存。比如我把我们队玩家的定时保存和玩家和Session的绑定关系就移到了这里。&lt;/p&gt;

&lt;p&gt;接下来就是路由系统的逻辑部分，先是要&lt;strong&gt;定义路由和路由版本控制&lt;/strong&gt;，记录每个路由缓存它的实体在哪里和版本。版本主要是用于后面的路由刷新和缓存的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;router-object-sys-load-cache.png&quot; alt=&quot;路由缓存拉取时序图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上是大致的路由缓存拉取时序图（图画得比较早，细节不准确，只表示大概的流程）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;router-object-sys-load-object.png&quot; alt=&quot;路由实体拉取时序图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上是大致的实体拉取时序图（图画得比较早，细节不准确，只表示大概的流程）:&lt;/p&gt;

&lt;p&gt;最重要的路由系统写逻辑是&lt;strong&gt;定义路由转移流程&lt;/strong&gt;。大致如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当然转移前要先把路由ID设为0，并保存一次数据。并把本地实体降级为缓存。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这里数据库保存可能失败，但是无论是否数据库保存成功，都应该降级为缓存，并且先执行降级，再执行保存。这里有两种容灾的情况，第一种是保存成功了但是本地超时或者出错，那么下一次操作拉取实体的时候会自然修复。另一种是真的保存失败，那么下一次拉取实体的时候会发现数据库中的路由版本号低于或等于本地，从而依然使用本地的数据，但是重新刷新路由ID。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后通知转移目标执行拉取实体的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等对方回复后继续本地操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由转移的过程中所有该对象的消息要进排队，结束后再转发（保证逻辑时序）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;router-object-sys-transfer.png&quot; alt=&quot;路由转移时序图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上是大致的路由转移时序图（图画得比较早，细节不准确，只表示大概的流程）:&lt;/p&gt;

&lt;p&gt;路由系统的读逻辑是&lt;strong&gt;定义消息路由流程&lt;/strong&gt;。即，发送路由消息时发给路由缓存中记录的路由ID。如果路由ID是自己，那就是发消息给自己。&lt;/p&gt;

&lt;p&gt;而对于接收端，要&lt;strong&gt;定义消息接收流程&lt;/strong&gt;。收到路由消息后第一步&lt;strong&gt;&lt;em&gt;可能&lt;/em&gt;&lt;/strong&gt;导致本地进程按类型和Key去拉取路由实体，如果发现缓存的路由目标地址不是自己，则再转发给自己记录的缓存路由ID。&lt;strong&gt;&lt;em&gt;转发前检查TTL，以免导致逻辑死循环&lt;/em&gt;&lt;/strong&gt;。时序大致如下（图画得比较早，细节不准确，只表示大概的流程）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;router-object-sys-msg.png&quot; alt=&quot;路由消息时序图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里发生路由ID不一致时，粗略上看有两种情况，第一种是来源版本号大于或等于本地，这时候因为如果本地记录的路由ID不是自己，则本地不是实体，那么收到路由消息后要&lt;strong&gt;&lt;em&gt;触发本地进程拉取实体的操作&lt;/em&gt;&lt;/strong&gt;，这时会拿到最新的路由版本号。这个版本号必然是最新的，不会低于任何一个缓存。&lt;/p&gt;

&lt;p&gt;另一种就是来源版本号低于本地，那就是来源进程的缓存过期了，那么这里要&lt;strong&gt;定义路由刷新流程&lt;/strong&gt;。即直接通知来源本地的版本号和路由ID。这种情况下本地的路由ID也并不一定是最新的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比如A转移给B，B转移给C，那么这时候A里记录的还是B。这时候如果有过期的D发消息给A，那么A通知D的是B而不是C。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时收到路由刷新的进程就要判定刷新通知的版本号和本地版本号，然后&lt;strong&gt;&lt;em&gt;刷新通知的路由版本号大于本地时才更新路由信息&lt;/em&gt;&lt;/strong&gt;。这样，最后所有的进程总能更新到最新的路由，并且能避免转移实体时集中的通知操作和通知失败的处理。&lt;/p&gt;

&lt;h3 id=&quot;使用约定手动部分&quot;&gt;使用约定（手动部分）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）按类型区分，路由Key的类型固定（一个string+一个int64）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）每种路由对象类型必须指定一个逻辑对象类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）实现实体拉取方法和缓存拉取方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）路由位置（拥有者的ID）必须是ID+版本号的组合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）拉取实体和缓存时必须设置路由数据中记录的实体所在进程ID和版本号。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果拉取实体的时候路由ID是0，则要把本地的进程ID保存进实体数据中，并且成功后才真正转为实体&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）实现实体的保存方法，而且保存过程中绝不能刷新对逻辑对象数据的引用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）保存实体的时候，必须保存进程ID和版本号，如果逻辑对象中也有记录这些信息，要保证数据一致&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）转移实体的时候必须版本号+1，并且要支持转移给0进程（表示不在任何进程上）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）一定要支持reload，因为每次缓存更新和缓存升级为实体都会触发reload&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）每种对象类型要同时定义manager的类型和对象路由类型，并定义manager的ID&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（必须）每种对象类型拉取数据的时候，当且仅当远端的路由版本号大于本地时才刷新数据&lt;strong&gt;（等于时也不能刷新）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（可选）根据类型指定实体拉取管理规则（比如公会实体只能在公会服务器，其他地方都是缓存）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（可选）区分缓存拉取和实体数据拉取&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（可选）定义拉取和移除缓存或实体的回调&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也是因为使用约定非常多，也容易出错，而且并没有很好的编程语言级别的功能能完全校验这些约定，特别是缓存的只读特性只能人工保证，这些直接导致了接入的复杂度。这也是直接导致隔离性没有消息路由系统好的原因。&lt;/p&gt;

&lt;h3 id=&quot;统一接口自动部分&quot;&gt;统一接口（自动部分）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;能够自动完成长时间不使用的实体对象的降级（到缓存）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;能够自动完成长时间不使用的缓存对象的淘汰&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;自动完成最后使用时间的标记&lt;/li&gt;
  &lt;li&gt;自动执行缓存的定时更新&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;路由消息转发接口&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多个任务同时拉取缓存或实体时的任务排队&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;路由层协议嵌入到Server间消息协议中和自动的路由消息数据填充&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;进入路由任务时自动拉取路由实体&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加粗的都是复杂并且麻烦的流程。&lt;/p&gt;

&lt;h2 id=&quot;和消息路由服务对比&quot;&gt;和消息路由服务对比&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较项&lt;/th&gt;
      &lt;th&gt;对象路由&lt;/th&gt;
      &lt;th&gt;消息路由服务&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;运维难度&lt;/td&gt;
      &lt;td&gt;简单&lt;/td&gt;
      &lt;td&gt;复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;接入复杂度&lt;/td&gt;
      &lt;td&gt;复杂&lt;/td&gt;
      &lt;td&gt;简单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;代码复用&lt;/td&gt;
      &lt;td&gt;高&lt;/td&gt;
      &lt;td&gt;低&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上面是一个简单的对比，消息路由运维复杂是因为需要单独维护一组服务器的负载均衡、容灾、扩缩容策略和缓存处理等等。基本上是一个独立的服务集群，所以比较复杂。&lt;/p&gt;

&lt;p&gt;而对象路由代码复用度高是因为很多地方和逻辑相关，所以可以复用很多共通的逻辑，比如生命周期和定时器、超时、重试、重试限制和错误处理等等。并且可以复用已有的消息协议结构，做到透明转发。还可以复用目前已有的日志系统、统计系统和分析系统。&lt;/p&gt;

&lt;p&gt;但是也是由于路由系统的复杂性导致上面列举的约定条目很多，容易出错或遗漏，而导致每一种路由对象的接入都十分复杂。而且不同类型的路由对象本身有一些规则上的区别。而如果是消息路由服务，则只需要通过几个简单的接口进行订阅、发布和反订阅即可。并且要求订阅者是唯一的，所以再加个心跳检查订阅者是否还有效即可。&lt;/p&gt;

&lt;p&gt;当然如果是消息路由服务，由于逻辑隔离了，所以整个数据的流程会更复杂。因为在对象路由中，有一些行为可以合并并且更优化地执行（比如路由刷新的流程）。&lt;/p&gt;

&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;这一套对象路由系统比较复杂，或许以上设计中也还存在着一些问题，欢迎大家指出讨论。即便没有严重的问题，目前的版本的代码实现必然还存在很多细节问题。等到验证过一些系统和模块并且稳定之后，我会尝试把它抽离并开源出来。这样容易在更多的项目上复用，并进一步完善细节和稳定性。&lt;/p&gt;</content><author><name></name></author><category term="消息队列" /><category term="进程间通信" /><summary type="html"></summary></entry><entry><title type="html">近期的一个协程流程BUG</title><link href="/article/work/2017-01-02/1313.html" rel="alternate" type="text/html" title="近期的一个协程流程BUG" /><published>2017-01-03T07:13:25+08:00</published><updated>2017-01-03T07:13:25+08:00</updated><id>/article/work/2017-01-02/1313</id><content type="html" xml:base="/article/work/2017-01-02/1313.html">&lt;p&gt;最近一直没什么时间整理近期碰到的问题，今天思考了一下之前碰到的一个临时处理的BUG，顺便写点东西清理一下思路。&lt;/p&gt;

&lt;p&gt;其实严格来说这个BUG更应该是一个流程试用问题，不过这个问题应该是需要能在协程库里检测并抛出错误来。&lt;/p&gt;

&lt;h2 id=&quot;libcopp的执行流程&quot;&gt;&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的执行流程&lt;/h2&gt;
&lt;p&gt;这个BUG涉及最底层context的执行流程，这个协程库切入有两个接口（start和resume），截止目前为止，这两个接口其实是对等的，然后有一个切出接口（yield）。切入的时候需要记录调用者的执行上下文，用于在切出时上下文切出到哪里。问题是各种情况下的这个上下文保存的执行状态。&lt;/p&gt;

&lt;p&gt;然后再来看上下文切换的代码，第一部分是首次切入的入口（调用start函数）。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coroutine_context_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutine_context_callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcontext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// copy jump_src_data_t in case it's destroyed later
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;jump_src_data_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_src_data_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// this must in a coroutine
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;coroutine_context_base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// update caller of to_co
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caller_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// save from_co's fcontext and switch status
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UTIL_CONFIG_NULLPTR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callee_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// from coroutine change status from running to ready
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_READY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// this_coroutine
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;set_this_coroutine_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// run logic code
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_and_recv_retcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_FINISHED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// jump back to caller
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ins_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最重要的是&lt;em&gt;save from_co’s fcontext and switch status&lt;/em&gt;下面的这一段。这里的作用就是切入后要把跳入前的上下文保存到来源的协程中。&lt;/p&gt;

&lt;p&gt;然后是恢复的流程（调用resume/yield函数）：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coroutine_context_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcontext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcontext_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                     &lt;span class=&quot;n&quot;&gt;jump_src_data_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UTIL_CONFIG_NOEXCEPT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;copp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcontext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;jump_src_data_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap_success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// can not use any more stack now
// can not initialize those vars here
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef COPP_MACRO_USE_SEGMENTED_STACKS
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ROOT-&amp;gt;A: jump_transfer.from_co == NULL, jump_transfer.to_co == A, from_sctx == A.caller_stack_, skip backup segments
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// A-&amp;gt;B.start(): jump_transfer.from_co == A, jump_transfer.to_co == B, from_sctx == B.caller_stack_, backup segments
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// B.yield()-&amp;gt;A: jump_transfer.from_co == B, jump_transfer.to_co == NULL, from_sctx == B.callee_stack_, skip backup segments
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UTIL_CONFIG_NULLPTR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__splitstack_getcontext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callee_stack_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callee_stack_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callee_stack_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__splitstack_getcontext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__splitstack_setcontext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_sctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segments_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcontext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copp_jump_fcontext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_src_data_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * save from_co's fcontext and switch status
     * we should use from_co in transfer_t, because it may not jump from jump_transfer.to_co
     *
     * if we jump sequence is A-&amp;gt;B-&amp;gt;C-&amp;gt;A.resume(), and if this call is A-&amp;gt;B, then
     * jump_src-&amp;gt;from_co = C, jump_src-&amp;gt;to_co = A, jump_transfer.from_co = A, jump_transfer.to_co = B
     * and now we should save the callee of C and set the caller of A = C
     *
     * if we jump sequence is A-&amp;gt;B.yield()-&amp;gt;A, and if this call is A-&amp;gt;B, then
     * jump_src-&amp;gt;from_co = B, jump_src-&amp;gt;to_co = NULL, jump_transfer.from_co = A, jump_transfer.to_co = B
     * and now we should save the callee of B and should change the caller of A
     *
     */&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// update caller of to_co if not jump from yield mode
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UTIL_CONFIG_NULLPTR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caller_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UTIL_CONFIG_NULLPTR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callee_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_RUNNING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_READY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_FINISHED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// if in finished status, change it to exited
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_EXITED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// private data
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// this_coroutine
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;set_this_coroutine_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// resume running status of from_co
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;swap_success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap_success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_READY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap_success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jump_transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_co&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN_CRS_RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，需要关注的部分是&lt;em&gt;update caller of to_co if not jump from yield mode&lt;/em&gt;后面的保存上下下文的部分。&lt;/p&gt;

&lt;p&gt;所以到这里可以看到第一个麻烦的地方，流程上的两种（start/resume和yield）和上下文切换的两种（首次和后续）并不匹配；第二个麻烦的地方在于只有在切入完成以后才能拿到切入时切入方的上下文。所以导致执行流程比较复杂。&lt;/p&gt;

&lt;h2 id=&quot;执行流程&quot;&gt;执行流程&lt;/h2&gt;
&lt;p&gt;首先是正常的执行流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外部-&amp;gt;协程A（yield）[-&amp;gt;外部(resume)-&amp;gt;协程A(yield)]…-&amp;gt;外部&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这时候，首次切入的时候，由首次的回调函数保存上下文。yield时，相当于切入的&lt;strong&gt;copp_jump_fcontext&lt;/strong&gt;完成return，而后由后面的代码完成把上下文保存进协程的工作。resume的时候，相当于yield的&lt;strong&gt;copp_jump_fcontext&lt;/strong&gt;完成return，然后用同样的方式保存上下文。&lt;/p&gt;

&lt;p&gt;其次是一个协程启动另一个协程，然后yield回前一个，走类似链式的流程，也是类似栈的流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外部-&amp;gt;协程A（start）-&amp;gt;协程B（yield）-&amp;gt;协程A（yield）-&amp;gt;外部&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种流程在携程B会记录caller为A的切出点，那么切回时流程也是走上面第一种情况一样的流程。&lt;/p&gt;

&lt;h2 id=&quot;问题流程&quot;&gt;问题流程&lt;/h2&gt;
&lt;p&gt;这两种流程最常用，并且已经使用很久了并不会有什么问题。然后第三种情况是最近一个特殊流程导致的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;外部-&amp;gt;协程A（start）-&amp;gt;协程B（resume）-&amp;gt;协程A（yield）-&amp;gt;…&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按最早的设计，协程A通过resume或者start接口第二次切入后，会更新协程A的caller为协程B（注释里写得状态信息更完整一些，但是考虑的调用链更长）。但是现在精简下调用链和这个执行流程，就不容易发现，这也是不正确的。因为这时候再也切不回最外部的调用者了。&lt;/p&gt;

&lt;p&gt;然后我的第一反应是，这样的话可以尝试后续的切入流程不再更新caller，只在第一次切入时更新caller。但是这样也不正确，因为假设协程B第二次通过resume切入协程A的时候，如果没有更新调用信息，那么其实协程A已经运行了一段代码了，而协程B里记录的还是老的值，这样协程B如果使用yield那么也是不对的。&lt;/p&gt;

&lt;p&gt;其实我还考虑过，协程的caller保存协程指针而不只是上下文。但是这样也是有问题的，一个是数据保存的流程和生命周期很难管理，其次是碰到复杂的调用流程的话，还是没法通知某些协程通知caller。&lt;/p&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;所以最终最安全的解决方案还是加个flag禁止掉这种调用。即一旦一个协程被切入了，只能通过yield切出。而同理，没有被切入的协程，必须通过start/resume切入。&lt;/p&gt;

&lt;p&gt;不过其实会触发这个BUG还有另一个原因，&lt;a href=&quot;https://github.com/atframework/libatbus&quot;&gt;libatbus&lt;/a&gt;有一处优化是，如果发送的消息目标是自己，那么会通过递归的方式直接回调接收事件（这也能够使发送给自己的消息少一次copy）。然后这个事件能导致协程调用resume。&lt;/p&gt;

&lt;p&gt;但是根据实际的使用情况，自己发给自己的消息是非常少见的，并且对外发豆油一次copy，发给自己减少掉这次copy意义不是很大。另外解包的CPU消耗应该本身比copy要高得多，所以我打算果断时间对&lt;a href=&quot;https://github.com/atframework/libatbus&quot;&gt;libatbus&lt;/a&gt;给自己发消息的时序也做一次优化，模拟成异步消息。这样也能解决一些隐性的前期以来问题。&lt;/p&gt;

&lt;p&gt;当然有限还是先加&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;的这个patch和单元测试。也是之前的单元测试没有覆盖到这种情况才导致现在才发现这种流程BUG。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Written with &lt;a href=&quot;https://stackedit.io/&quot;&gt;StackEdit&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="coroutine" /><category term="协程" /><category term="多线程" /><category term="消息队列" /><category term="进程间通信" /><summary type="html">最近一直没什么时间整理近期碰到的问题，今天思考了一下之前碰到的一个临时处理的BUG，顺便写点东西清理一下思路。</summary></entry><entry><title type="html">atsf4g完整游戏工程示例</title><link href="/article/2016-10-23/atsf4g_full_sample.html" rel="alternate" type="text/html" title="atsf4g完整游戏工程示例" /><published>2016-10-23T00:00:00+08:00</published><updated>2016-10-23T00:00:00+08:00</updated><id>/article/2016-10-23/atsf4g_full_sample</id><content type="html" xml:base="/article/2016-10-23/atsf4g_full_sample.html">&lt;nav class=&quot;toc&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#完整工程&quot; id=&quot;markdown-toc-完整工程&quot;&gt;完整工程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#指定登入流程&quot; id=&quot;markdown-toc-指定登入流程&quot;&gt;指定登入流程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#协议实现&quot; id=&quot;markdown-toc-协议实现&quot;&gt;协议实现&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#资源管理方面&quot; id=&quot;markdown-toc-资源管理方面&quot;&gt;资源管理方面：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#任务和消息分发&quot; id=&quot;markdown-toc-任务和消息分发&quot;&gt;任务和消息分发：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#数据库&quot; id=&quot;markdown-toc-数据库&quot;&gt;数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#配置加载&quot; id=&quot;markdown-toc-配置加载&quot;&gt;配置加载&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#数据结构优化&quot; id=&quot;markdown-toc-数据结构优化&quot;&gt;数据结构优化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#监控&quot; id=&quot;markdown-toc-监控&quot;&gt;监控&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#配置生成工具&quot; id=&quot;markdown-toc-配置生成工具&quot;&gt;配置生成工具&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#静态分析&quot; id=&quot;markdown-toc-静态分析&quot;&gt;静态分析&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#跨平台适配和工具适配&quot; id=&quot;markdown-toc-跨平台适配和工具适配&quot;&gt;跨平台适配和工具适配&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ci&quot; id=&quot;markdown-toc-ci&quot;&gt;CI&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#后续计划&quot; id=&quot;markdown-toc-后续计划&quot;&gt;后续计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;p&gt;近期仍然在搭建完整的游戏服务器架构。基于&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;atsf4g（asynchronously-tree server framework fo game）&lt;/a&gt;的完整解决方案终于接近完成。基本框架之前其实已经做完了，但是之前解决的只是基本的框架层代码，不包含任何特定的交互模型、协议模型、配置服务等等。这回就整理了一个只包含登入登出逻辑的完整工程，另外优化了一些小细节和周边工具的支持。&lt;/p&gt;

&lt;p&gt;完整示例地址： https://github.com/atframework/atsf4g-co/tree/full_sample&lt;/p&gt;

&lt;h2 id=&quot;完整工程&quot;&gt;完整工程&lt;/h2&gt;
&lt;p&gt;其实很多游戏服务在具体的通信模型，请求/响应的包装还有资源管理等等方面大同小异，可以复用的部分还是很多的，所以我就按我们上一个游戏的模型写了一个完整的sample，放在了&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/full_sample&quot;&gt;full_sample&lt;/a&gt;分支。&lt;/p&gt;

&lt;p&gt;所谓完整的sample，就是按照具体项目的设计，保留了主要的通信流程和交互的封装。这里CS协议采用了&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt;（顺便升级到了proto3版本），然后保留了&lt;em&gt;登入逻辑，踢出逻辑，基本信息拉取逻辑和基本的ping/pong逻辑&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;指定登入流程&quot;&gt;指定登入流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;client-&amp;gt;loginsvr: 请求鉴权，生成token&lt;/li&gt;
  &lt;li&gt;loginsvr-&amp;gt;client: 然后拿token去gamesvr登入。loginsvr仅实现了最基本的鉴权方式（帐号&amp;amp;密码）。由loginsvr负责gamesvr的负载均衡。&lt;/li&gt;
  &lt;li&gt;client-&amp;gt;gamesvr: 使用token登入&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;协议实现&quot;&gt;协议实现&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;鉴权和负载均衡：loginsvr仅实现了最基本的鉴权方式（帐号&amp;amp;密码）。由loginsvr负责gamesvr的负载均衡。loginsvr全程无状态。&lt;/li&gt;
  &lt;li&gt;登入流程：保证用户数据只在一处上线，保留踢出逻辑，故障修复功能&lt;/li&gt;
  &lt;li&gt;Ping/Pong：保留加速器检测和网络短期拥塞的处理，token续期&lt;/li&gt;
  &lt;li&gt;拉取信息：作为一个典型逻辑处理的流程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;资源管理方面&quot;&gt;资源管理方面：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定时自动保存&lt;/li&gt;
  &lt;li&gt;缓存和自动失效管理（配合断线重连）&lt;/li&gt;
  &lt;li&gt;Session管理&lt;/li&gt;
  &lt;li&gt;统一配置管理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;任务和消息分发&quot;&gt;任务和消息分发：&lt;/h3&gt;
&lt;p&gt;这个项目指定使用协程，所以会比&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;master&lt;/a&gt;多依赖一个&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;，用来做协程任务管理的封装。然后默认模型是Request/Pesponse的模式，由协程任务管理器管理每个协程的生命周期。&lt;br /&gt;
然后在协程任务的基础上包装了消息分发的规则，要求消息分发管理器必须实现一些接口，比如：提取消息ID或提取消息名称、打解包方式、怎么存储和提取关联的协程任务ID等等。然后由统一的方式启动新协程任务或者恢复协程上下文。&lt;br /&gt;
因为是最小工程，目前只保留了客户端-服务器（CS）消息dispatcher和、服务器间（SS）消息dispatcher和数据库（DB）消息dispatcher。其他的暂时没移植过来，不过后续因为有一些基本的功能也是蛮通用的，后续有空可能也会再移植一些过来。比如Curl消息dispatcher来处理HTTP消息，再或者websocket。到时候移植的时候都会再重构一次代码，但是对于需要额外依赖的功能会更谨慎一些，因为毕竟是个通用的sample所以不想加一些可能用不到的依赖进来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;C++协程&lt;/a&gt;因为暴露了原始地址，并且要切换前后地址不变，所以要专门给每个协程分配栈。我们这里走的是系统接口&lt;em&gt;（Linux走mmap+mprotect,Windows走VirtualAlloc+VirtualProtect）&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;虽然&lt;a href=&quot;https://gcc.gnu.org/wiki/SplitStacks&quot;&gt;gcc在linux下支持动态栈&lt;/a&gt;功能，并且动态栈特别适合协程（因为基本可以按需分配栈内存），但是由于并不跨平台并且文档不多，所以只是&lt;a href=&quot;https://github.com/owt5008137/libcopp&quot;&gt;libcopp&lt;/a&gt;底层支持，并没有默认启用。以后等这个功能更成熟一些（主要是可以控制最大栈大小的话）可以尝试默认用动态栈。&lt;/p&gt;

&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;p&gt;完整游戏服务器sample的话，数据库肯定是不能少的。这方面直接用了&lt;a href=&quot;http://redis.io/&quot;&gt;redis&lt;/a&gt;，并且是&lt;a href=&quot;http://redis.io/topics/cluster-spec&quot;&gt;redis cluster&lt;/a&gt;，由于&lt;a href=&quot;http://redis.io/topics/cluster-spec&quot;&gt;redis cluster&lt;/a&gt;目前并没有一个很好的connector，所以我们自己开发了&lt;strong&gt;&lt;a href=&quot;https://github.com/owt5008137/hiredis-happ&quot;&gt;hiredis-happ&lt;/a&gt;&lt;/strong&gt;（&lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt;高可用），基于&lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt;实现了对&lt;a href=&quot;http://redis.io/topics/cluster-spec&quot;&gt;redis cluster&lt;/a&gt;的接入并做了自动重连和自动失败重试的功能。所以整个工程比&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;master&lt;/a&gt;会再多依赖这两个库。&lt;/p&gt;

&lt;h3 id=&quot;配置加载&quot;&gt;配置加载&lt;/h3&gt;
&lt;p&gt;配置加载走的是&lt;a href=&quot;https://github.com/xresloader/&quot;&gt;xresloader&lt;/a&gt;的方案，主要流程是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义配置&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt;结构，转出pb文件。&lt;/li&gt;
  &lt;li&gt;定义excel转换规则&lt;/li&gt;
  &lt;li&gt;用&lt;a href=&quot;https://github.com/xresloader/xresconv-gui&quot;&gt;xresloader-gui&lt;/a&gt;或&lt;a href=&quot;https://github.com/xresloader/xresconv-cli&quot;&gt;xresloader-cli&lt;/a&gt;调用&lt;a href=&quot;https://github.com/xresloader/xresloader&quot;&gt;xresloader&lt;/a&gt;加载pb和转换规则转换出配置数据二进制文件&lt;/li&gt;
  &lt;li&gt;在代码里定义配置的类型，key类型和容器类型（可选key-value，key-list，index-value，index-list）&lt;/li&gt;
  &lt;li&gt;配置管理器里指定加载文件名称和怎么读取key&lt;/li&gt;
  &lt;li&gt;[可选] 可以根据需要指定数据过滤规则和如果值是list类型的话可以指定排序规则&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数据结构优化&quot;&gt;数据结构优化&lt;/h3&gt;
&lt;p&gt;因为是整理框架，所以我们之前项目里有一些非跨平台或者编译器版本限定的东西移植过来前就再优化了一下。比如一些不需要排序的容器改成了根据环境尽量使用hash_map。有些调用（特别是sprintf之类）包了一层，用于解决某些编译器里会有warning的问题。并且尽量使用safe的API。&lt;/p&gt;

&lt;h3 id=&quot;监控&quot;&gt;监控&lt;/h3&gt;
&lt;p&gt;监控方面目前只是加了个log分类，还没写进去。这个sample基本只会监控协程任务的延迟问题，还有RPC的响应时间。上报的话目前只接入本地日志。因为监控和报警的话不同的项目可以接入不同的系统，差异很大，并且具体的业务逻辑得具体的业务自己加，所以框架也只能监控最基本的东西。&lt;/p&gt;

&lt;h3 id=&quot;配置生成工具&quot;&gt;配置生成工具&lt;/h3&gt;
&lt;p&gt;我们以前的配置生成工具是&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;写得。当时并不会&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;，并且是想&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;刚好本来就是设计来当通过模板生成code的（虽然大部分是Web相关的）。好像很合适做成配置模板然后生成各个服务器的配置。但是慢慢发现，用&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;一次性生成多个服务器模板并不是很方便。特别是系统信息检测和多个server传递多个参数并且隔离server配置后，服务器间要在配置上建立关系，很不方便。&lt;/p&gt;

&lt;p&gt;之前的&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;的生成系统会通过加载一个服务器组配置，然后通过调用另一个&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;文件，把输出流重定向到生成目标，以此来实现加载模板脚本生成配置。但是这样的话首先意味着很多&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;脚本会完全重新加载，并且参数传递只能走命令行。再就是比如loginsvr在开发环境需要知道gamesvr关联的gateway绑定的地址，那么就只能通过统一的算法，然后通过传参加重新计算一次得出来，非常麻烦。&lt;/p&gt;

&lt;p&gt;最近看了下&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;的&lt;a href=&quot;http://www.makotemplates.org/&quot;&gt;mako&lt;/a&gt;库，似乎拿来做模板生成挺好用，不过麻烦的一点是&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;的ini读取有纯&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;的扩展实现可以支持多个层级，但是&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;的不行。并且python2和python3在解析配置文件的支持度上还是差异比较大。但是这比起&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;的问题倒不是什么大事儿。而且&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;比&lt;a href=&quot;http://php.net/&quot;&gt;php&lt;/a&gt;容易安装，标准库丰富得多，特别是生成配置的时候需要检测系统信息就不需要再借助外部工具了，所以现在就用&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;重写了配置和脚本生成系统。&lt;/p&gt;

&lt;p&gt;脚本生成也像以前一样预留可选预加载&lt;a href=&quot;https://github.com/jemalloc/jemalloc&quot;&gt;jemalloc&lt;/a&gt;或者&lt;a href=&quot;https://github.com/gperftools/gperftools&quot;&gt;tcmalloc&lt;/a&gt;和设置响应的debug配置，还有&lt;a href=&quot;http://valgrind.org/&quot;&gt;valgrind&lt;/a&gt;支持。&lt;/p&gt;

&lt;p&gt;不过截止至写这篇文章的时候，这部分还没有全部完成，只是大体完成。预计很快就会finish并且merge进&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;master&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;静态分析&quot;&gt;静态分析&lt;/h3&gt;
&lt;p&gt;之前我们项目里的静态分析使用的是&lt;a href=&quot;http://cppcheck.sourceforge.net/&quot;&gt;cppcheck&lt;/a&gt;，但是其实&lt;a href=&quot;http://cppcheck.sourceforge.net/&quot;&gt;cppcheck&lt;/a&gt;配置起来比较麻烦，特别是工程项目大了以后，各种选项比较麻烦，并且cppcheck还是有一定的误报率。所以现在&lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;clang-analyzer&lt;/a&gt;的流程更贴近编译器行为，而且更精确，所以我先接入了&lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;clang-analyzer&lt;/a&gt;。不过不清楚和&lt;a href=&quot;http://cppcheck.sourceforge.net/&quot;&gt;cppcheck&lt;/a&gt;相比是否有漏报，等再过一段时间有空了我再把&lt;a href=&quot;http://cppcheck.sourceforge.net/&quot;&gt;cppcheck&lt;/a&gt;也接入进来看看。&lt;/p&gt;

&lt;h3 id=&quot;跨平台适配和工具适配&quot;&gt;跨平台适配和工具适配&lt;/h3&gt;
&lt;p&gt;因为是框架级的整理，所以在周边工具上也是需要适配一下跨平台和多种工具的，就列举一下碰到的问题吧&lt;/p&gt;

&lt;h4 id=&quot;clang-analyzer&quot;&gt;&lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang-analyzer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个静态分析接入倒是没什么问题，框架已经能做到3.8版本无报警了，但是sample还没有跑，过段时间我会跑跑看，因为&lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt;的原因，&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/full_sample&quot;&gt;full_sample&lt;/a&gt;在Windows下无法编译出二进制，但是框架可以，所以&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;master&lt;/a&gt;分支已经清理了所有的报警，&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/full_sample&quot;&gt;full_sample&lt;/a&gt;的话等过段时间在linux上编译一套llvm系工具再fix。不过整体不会有太大的问题。&lt;/p&gt;

&lt;h4 id=&quot;bash-on-windows&quot;&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Bash on windows&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;适配&lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Bash on windows&lt;/a&gt;的时候还是碰到了点问题的，首先不知道是哪些api微软没做完，&lt;a href=&quot;http://redis.io/&quot;&gt;redis&lt;/a&gt;在不设置仅bind ipv4的情况下，&lt;a href=&quot;http://redis.io/&quot;&gt;redis&lt;/a&gt;是起不来的。但是我们自己的框架其实是可以正常listen和使用ipv6。不过在bash on windows里并不能使用共享内存，所以配置生成工具就改成了在检查不到linux共享内存配置的时候就走IP。（Windows下的全局共享内存必须开管理员权限才能创建，为了防止上手困难，和开发环境麻烦，所以默认Windows下也是走tcp而不是共享内存，本身支持Windows也只是为了开发方便）&lt;/p&gt;

&lt;h4 id=&quot;mingw64msys2&quot;&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;MinGW64@MSYS2&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;MinGW64下编译框架和服务器代码是没有问题的，但是由于&lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt;不支持windows，而微软自己做的&lt;a href=&quot;https://github.com/MSOpenTech/Redis&quot;&gt;redis系列的porting&lt;/a&gt;并没有把&lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt;单独开放出来，做自动化工具比较麻烦，暂时也就没花这个时间去搞（理论上自己编译好prebuilt然后设置LIBHIREDIS_ROOT也是可以的）。现在在Mingw64上的状态是&lt;a href=&quot;https://github.com/atframework/atsf4g-co/&quot;&gt;master&lt;/a&gt;正常，&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/full_sample&quot;&gt;full_sample&lt;/a&gt;能编译但是链接不过。目前静态分析我都是在&lt;a href=&quot;https://msys2.github.io/&quot;&gt;msys2&lt;/a&gt;的mingw64里用源里的包跑，所以这也是&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/full_sample&quot;&gt;full_sample&lt;/a&gt;暂时还没处理静态分析的原因。&lt;/p&gt;

&lt;h3 id=&quot;ci&quot;&gt;CI&lt;/h3&gt;
&lt;p&gt;这个是准备最后才会接入的，所以目前也不急。&lt;/p&gt;

&lt;h2 id=&quot;后续计划&quot;&gt;后续计划&lt;/h2&gt;
&lt;p&gt;首先当然还是把配置生成解决掉，然后把上面的未完成部分一点一点解决掉。首先当然还是质量优先，所以静态分析是优先级比较高的部分。其他的就看情况吧。&lt;/p&gt;

&lt;p&gt;接下来整理出的框架会用于下一个项目。然后再一点一点地在这个框架的基础上搭建出更多的通用服务和配套工具。同时再来调整框架架构。现在完全是以源码的方式提供框架，这会导致很容易需要重新编译框架和一些不太改动的库，头文件分析也会浪费一些时间，所以等到工程更大了以后，必然还是会抽离成库和服务，然后封装成隔离性更好的设计（当然一定会保持开源的）。不过这也是后话了。&lt;/p&gt;</content><author><name></name></author><category term="libatbus" /><category term="cxx" /><category term="bus" /><category term="rpc" /><category term="cpp" /><category term="c++" /><category term="framework" /><category term="atframework" /><category term="coroutine" /><category term="libcopp" /><summary type="html"></summary></entry><entry><title type="html">atframework基本框架已经完成</title><link href="/article/work/2016-09-22/1301.html" rel="alternate" type="text/html" title="atframework基本框架已经完成" /><published>2016-09-23T01:10:11+08:00</published><updated>2016-09-23T01:10:11+08:00</updated><id>/article/work/2016-09-22/1301</id><content type="html" xml:base="/article/work/2016-09-22/1301.html">&lt;p&gt;好久没写blog了。最近空闲时间都在加紧完成&lt;a href=&quot;https://atframe.work&quot;&gt;atframework&lt;/a&gt;框架。总算是搞完了，并且搭建了一个静态介绍页。以后有空慢慢加文档进去。&lt;/p&gt;

&lt;p&gt;主页: &lt;a href=&quot;https://atframe.work/&quot;&gt;https://atframe.work/&lt;/a&gt;&lt;br /&gt;
Github: &lt;a href=&quot;https://github.com/atframework/&quot;&gt;https://github.com/atframework/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前这个项目已经是一个小型游戏服务器的完整框架，包括服务器间实例的管理、客户端和服务器的内部协议和通信机制。并且实现了纯C的port。&lt;br /&gt;
然后&lt;a href=&quot;https://github.com/atframework/atsf4g-co/tree/master/sample/atgw_cli_inner_hello&quot;&gt;https://github.com/atframework/atsf4g-co/tree/master/sample/atgw_cli_inner_hello&lt;/a&gt;里提供了c++的客户度端的代码示例，&lt;a href=&quot;https://github.com/atframework/AtgwInnerCli-CSharp&quot;&gt;https://github.com/atframework/AtgwInnerCli-CSharp&lt;/a&gt;里提供了C#的客户端代码示例。&lt;br /&gt;
使用的都是同一个纯C的协议porting。这样无论cocos还是unity框架接入都不困难了。其他的框架也可以直接用这个纯C的porting来接入。&lt;/p&gt;

&lt;p&gt;然后接下来我会用协程的设计模型整理出一个完整项目的小demo结构，以便以后用起来方便。最近也没时间写完整的技术总结。不过本来要给新公司的大家讲解服务器的设计和新框架的设计要点，我就把PPT分享出来吧。&lt;/p&gt;

&lt;p&gt;PPT托管在Office365上，看不着的话可能得自备梯子。&lt;br /&gt;
[iframe src=”https://onedrive.live.com/embed?cid=9E9045AB22B1A22D&amp;amp;resid=9E9045AB22B1A22D%2176769&amp;amp;authkey=AFmVYMcY1mwYeuY&amp;amp;em=2” width=”804” height=”654”]&lt;/p&gt;</content><author><name></name></author><category term="atframework" /><category term="c++0x/11" /><category term="c++11" /><category term="cpp" /><category term="g++" /><category term="gcc" /><category term="消息队列" /><category term="进程间通信" /><summary type="html">好久没写blog了。最近空闲时间都在加紧完成atframework框架。总算是搞完了，并且搭建了一个静态介绍页。以后有空慢慢加文档进去。</summary></entry></feed>